<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack4</title>
    <link href="/2020/08/23/webpack/"/>
    <url>/2020/08/23/webpack/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack的概念"><a href="#webpack的概念" class="headerlink" title="webpack的概念"></a>webpack的概念</h2><p>webpack是一个用于现代JavaScript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener">依赖图(dependency graph)</a>，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="一、搭建项目目录"><a href="#一、搭建项目目录" class="headerlink" title="一、搭建项目目录"></a>一、搭建项目目录</h3><div class="hljs"><pre><code class="hljs diff"> webpack-learn |- /src|- index.js|- index.html</code></pre></div><p>初始化<code>package.json</code>:</p><div class="hljs"><pre><code class="hljs bash">npm init -y</code></pre></div><p><a href="https://docs.npmjs.com/cli/init" target="_blank" rel="noopener">npm init</a>将所在目录设为npm package。</p><p><img src="/blogImg/image-20200823150153329.png" srcset="/img/loading.gif" alt="image-20200823150153329"></p><h3 id="二、安装webpack"><a href="#二、安装webpack" class="headerlink" title="二、安装webpack"></a>二、安装webpack</h3><p>推荐局部安装，全局安装会造成版本指定，如果多个项目依赖的版本不同，会造成构建失败</p><div class="hljs"><pre><code class="hljs bash">npm i webpack webpack-cli -D</code></pre></div><p>webpack4需要引入webpack-cli，执行上述命令后，会生成一个node_modules文件夹和一个package-lock.json文件</p><h2 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h2><p>修改package.json文件夹，添加一个build（构建）脚本</p><div class="hljs"><pre><code class="hljs json">"scripts": &#123;  "build": "webpack"&#125;</code></pre></div><p>然后执行命令</p><div class="hljs"><pre><code class="hljs bash">npm run build</code></pre></div><p>输出如下图所示：</p><p><img src="/blogImg/image-20200823153339819.png" srcset="/img/loading.gif" alt="image-20200823153339819"></p><p>webpack4之前需要在webpack.config.js文件中指定入口点和输出文件。这里没有报错，因为从webpack4开始，默认将<code>./src/index.js</code>这个文件定义为入口点（entry point），默认在<code>./dist/main.js</code>输出（output）。</p><h3 id="production（生产）和development（开发）模式"><a href="#production（生产）和development（开发）模式" class="headerlink" title="production（生产）和development（开发）模式"></a>production（生产）和development（开发）模式</h3><p>webpack4引入了生产模式和开发模式</p><p>修改package.json文件夹中的script</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-string">"scripts"</span>: &#123;  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack --mode development"</span>,  <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack --mode production"</span>&#125;</code></pre></div><p>此时执行npm run dev，查看<code>./dist/main.js</code></p><p><img src="./blogImg/image-20200823154631661.png" srcset="/img/loading.gif" alt="image-20200823154631661"></p><p>是一个没有压缩过的bundle（包）文件。</p><p>而执行npm run build时，生成的是一个压缩后的bundle</p><p><strong>production mode(生产模式)</strong> 可以开箱即用地进行各种优化。 包括压缩，作用域提升，tree-shaking 等。<strong>development mode(开发模式)</strong>针对速度进行了优化，仅仅提供了一种不压缩的 bundle 。</p><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>新建一个bro.js</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bro = <span class="hljs-function">(<span class="hljs-params">greetings</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;greetings&#125;</span>, bro`</span>&#125;<span class="hljs-keyword">export</span> &#123;    bro&#125;;</code></pre></div><p>在index.js中引入</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;    bro&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./bro'</span>;<span class="hljs-built_in">console</span>.log(bro(<span class="hljs-string">'Dude'</span>));</code></pre></div><p>index.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>控制台输入<code>http-server -o</code> 运行，得不到想要的结果。因为webpack默认只能理解JavaScript和JSON文件，需要通过loader或插件（plugin）使得webpack能够处理其他的文件。</p><p>在主目录下新建一个webpack.config.js文件夹，在这个文件中自定义配置。</p><p><img src="/blogImg/image-20200823204034939.png" srcset="/img/loading.gif" alt="image-20200823204034939"></p><h3 id="HTML-webpack插件"><a href="#HTML-webpack插件" class="headerlink" title="HTML webpack插件"></a>HTML webpack插件</h3><p>命令行输入安装相对应的loader</p><div class="hljs"><pre><code class="hljs bash">npm i -D html-webpack-plugin html-loader</code></pre></div><p>修改webpack.config.js文件</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> HtmlWebPackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-built_in">module</span>: &#123;        rules: [&#123;            <span class="hljs-comment">// loader的两个属性</span>            test: <span class="hljs-regexp">/\.html$/</span>,<span class="hljs-comment">// test: 识别哪些文件会被转换</span>            use: [&#123;<span class="hljs-comment">// use: 定义出在进行转化时，应该使用哪个loader</span>                loader: <span class="hljs-string">"html-loader"</span>,                options: &#123;                    minimize: <span class="hljs-literal">true</span>                &#125;            &#125;]        &#125;]    &#125;,    <span class="hljs-comment">// 插件</span>    plugins: [        <span class="hljs-keyword">new</span> HtmlWebPackPlugin(&#123;            template: <span class="hljs-string">"./src/index.html"</span>,            filename: <span class="hljs-string">"./index.html"</span>        &#125;)    ]&#125;</code></pre></div><p>修改完成后，再次执行<code>npm run build</code>，会看到dist目录下生成了一个index.html文件</p><p>再次运行，可以看到控制台成功输出</p><p><img src="/blogImg/image-20200823210359851.png" srcset="/img/loading.gif" alt="image-20200823210359851"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/08/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/08/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式，在JS中，正则表达式也是对象。</p><p>正则表达式的作用：</p><ul><li>被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文。</li><li>用于过滤掉页面内容中的一些敏感词（替换），或者从字符串中获取我们想要的特定部分（提取）等。</li></ul><p>特点：</p><ul><li>灵活性、逻辑性和功能性非常强</li><li>可以迅速地用极简单的方式达到字符串的复杂控制</li></ul><h2 id="在JavaScript中的使用"><a href="#在JavaScript中的使用" class="headerlink" title="在JavaScript中的使用"></a>在JavaScript中的使用</h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ol><li><p>使用RegExp对象创建</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> regexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/123/</span>);</code></pre></div></li><li><p>直接使用字面量创建</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> regExp = <span class="hljs-regexp">/123/</span>;</code></pre></div></li></ol><h3 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h3><p>使用test()正则对象方法，如果符合返回true，不符合返回false</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rg = <span class="hljs-regexp">/123/</span>;<span class="hljs-comment">// 只要包含123就返回true</span>rg.test(<span class="hljs-number">123</span>);<span class="hljs-comment">// true</span>rg.test(<span class="hljs-string">'abc'</span>);<span class="hljs-comment">// false</span></code></pre></div><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">详情查看MDN</a></p><h4 id="边界符"><a href="#边界符" class="headerlink" title="边界符 ^ $"></a>边界符 ^ $</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^abc/</span>;<span class="hljs-comment">// 以abc开头</span><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/abc$/</span>;<span class="hljs-comment">// 以abc结尾</span><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/^abc$/</span>;<span class="hljs-comment">// 精确匹配，必须是abc</span></code></pre></div><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类  [ ]"></a>字符类  [ ]</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/[abc]/</span>;<span class="hljs-comment">// 只要包含a或b或c就返回true</span><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/^[a-z]$/</span>;<span class="hljs-comment">// 只有是a到z中的单个字母才返回true</span></code></pre></div><h4 id="字符组合"><a href="#字符组合" class="headerlink" title="字符组合"></a>字符组合</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^[a-zA-Z0-9_-]$/</span>;<span class="hljs-comment">// 大小写、数字、下划线和短横线中任何一个</span><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/^[^a-zA-Z0-9_-]$/</span>;<span class="hljs-comment">//字符类[]中的^表示取反操作，不能包含……</span></code></pre></div><h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// * 可以出现0次或多次</span><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^a*$/</span>;<span class="hljs-comment">// "", "a", "aaa"...</span><span class="hljs-comment">// + 出现1次或多次</span><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/^a+$/</span>;<span class="hljs-comment">// "a", "aaa"...</span><span class="hljs-comment">// ? 0次或1次</span><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/^a?$/</span>;<span class="hljs-comment">// "", "a"</span><span class="hljs-comment">// &#123;3&#125; 重复3次</span><span class="hljs-keyword">let</span> reg3 = <span class="hljs-regexp">/^a&#123;3&#125;$/</span>;<span class="hljs-comment">// "aaa"</span><span class="hljs-comment">// &#123;3,&#125; 大于等于3次</span><span class="hljs-keyword">let</span> reg4 = <span class="hljs-regexp">/^a&#123;3,&#125;$/</span>;<span class="hljs-comment">// "aaa", "aaaaaaa"...</span><span class="hljs-comment">// &#123;3, 5&#125; 大于等于3,且小于等于5</span><span class="hljs-keyword">let</span> reg5 = <span class="hljs-regexp">/^a&#123;3,5&#125;$/</span>;<span class="hljs-comment">// "aaa", "aaaa", "aaaaa"</span><span class="hljs-comment">// 小括号 表示优先级</span><span class="hljs-keyword">let</span> reg6 = <span class="hljs-regexp">/^(abc)&#123;3&#125;$/</span>;<span class="hljs-comment">// "abcabcabc"</span></code></pre></div><blockquote><p>注意：{}中间不能加空格</p></blockquote><h4 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h4><p>常见模式的简单写法</p><div class="hljs"><pre><code class="hljs txt">\d   等价于 [0-9]\D 等价于 [^0-9]\w   等价于 [A-Za-z0-9_]具体查看MDN</code></pre></div><h2 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h2><h3 id="replace替换"><a href="#replace替换" class="headerlink" title="replace替换"></a>replace替换</h3><p>replace方法第一个参数可以为正则表达式</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">"hello world"</span>;<span class="hljs-keyword">let</span> newStr = str.replace(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'good'</span>);<span class="hljs-comment">// or</span><span class="hljs-keyword">let</span> newStr = str.replace(<span class="hljs-regexp">/hello/</span>, <span class="hljs-string">'good'</span>);</code></pre></div><h3 id="正则表达式参数"><a href="#正则表达式参数" class="headerlink" title="正则表达式参数"></a>正则表达式参数</h3><p><code>表达式/[switch]</code><br>switch修饰符声明按照什么模式来匹配，有三种值</p><ul><li>g：全局匹配</li><li>i：忽略大小写</li><li>gi：全局匹配+忽略大小写</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">"big big world"</span>;<span class="hljs-keyword">let</span> newStr = str.replace(<span class="hljs-regexp">/big/</span>, <span class="hljs-string">'small'</span>);<span class="hljs-comment">// "small big world"</span><span class="hljs-comment">// 不加全局匹配只会替换第一个匹配的</span><span class="hljs-keyword">let</span> newStr1 = str.replace(<span class="hljs-regexp">/big/g</span>, <span class="hljs-string">'small'</span>); <span class="hljs-comment">// "small small world"</span></code></pre></div><h2 id="简单应用案例"><a href="#简单应用案例" class="headerlink" title="简单应用案例"></a>简单应用案例</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>请输入用户名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^[a-zA-Z0-9_-]&#123;6,16&#125;$/</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.name'</span>);</span><span class="actionscript">            name.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">                <span class="hljs-keyword">if</span>(reg.test(<span class="hljs-keyword">this</span>.value)) &#123;</span><span class="javascript">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'true'</span>)</span><span class="actionscript">                    <span class="hljs-comment">// 修改样式等操作。。。</span></span><span class="actionscript">                &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'false'</span>)</span><span class="actionscript">                    <span class="hljs-comment">// 修改样式等操作。。。</span></span>                &#125;            &#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">工具</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序-JS版</title>
    <link href="/2020/08/19/%E6%8E%92%E5%BA%8F-JS%E7%89%88/"/>
    <url>/2020/08/19/%E6%8E%92%E5%BA%8F-JS%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-keyword">let</span> flag;    <span class="hljs-keyword">let</span> temp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;        flag = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<span class="hljs-comment">// 内层循环</span>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">// 比较相邻两个值</span>                flag = <span class="hljs-literal">false</span>;                temp = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = arr[j];                arr[j] = temp;            &#125;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-comment">// 如果flag为true,表示上轮循环已经有序</span>            <span class="hljs-keyword">return</span> arr;        &#125;    &#125;&#125;</code></pre></div><h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅拷贝与深拷贝</title>
    <link href="/2020/08/19/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/08/19/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用</p><p>深拷贝拷贝多层，每一层级的数据都会拷贝</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;    id: <span class="hljs-number">1</span>,    name: <span class="hljs-string">'uzi'</span>,    msg: &#123;        age: <span class="hljs-number">5</span>    &#125;&#125;<span class="hljs-keyword">let</span> a = &#123;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> b <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-comment">// 浅拷贝, msg只拷贝了引用</span>    a[b] = obj[b];&#125;a.msg.age = <span class="hljs-number">18</span>;<span class="hljs-comment">// obj.msg.age 也变为 18;</span><span class="hljs-comment">// ----------------------------------------------</span><span class="hljs-built_in">Object</span>.assign(a, obj);<span class="hljs-comment">// 复制对象,也是浅拷贝</span></code></pre></div><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用递归的方式</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span>(<span class="hljs-params">newObj, oldObj</span>) </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldObj) &#123;        <span class="hljs-comment">// 判断属性值为什么类型</span>        <span class="hljs-keyword">let</span> item = oldObj[k];        <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123; <span class="hljs-comment">// 类型为数组时, 数组也是Object,所以写前面</span>            newObj[k] = [];            deepCopy(newObj[k], item);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;<span class="hljs-comment">// 类型为对象</span>            newObj[k] = &#123;&#125;;            deepCopy(newObj[k], item);        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 简单数据类型</span>            newObj[k] = item;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高阶函数与闭包</title>
    <link href="/2020/08/18/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <url>/2020/08/18/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>高阶函数是对其他函数进行操作的函数，分为两种，接受函数作为参数或者将函数作为返回值进行输出</p><h3 id="接受函数作为参数"><a href="#接受函数作为参数" class="headerlink" title="接受函数作为参数"></a>接受函数作为参数</h3><p>典型的使用：回调函数</p><p><em>回调函数是作为参数传给另一个函数的函数，然后通过在外部函数内部调用该回调函数以完成某种操作</em></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数作为参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b, callback</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a+b);    callback &amp;&amp; callback();&#125;fn(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 回调函数</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1111'</span>);&#125;)</code></pre></div><h3 id="将函数作为返回值进行输出"><a href="#将函数作为返回值进行输出" class="headerlink" title="将函数作为返回值进行输出"></a>将函数作为返回值进行输出</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> functon() &#123;&#125;&#125;</code></pre></div><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>闭包（closure）：有权访问另一个函数作用域中变量的函数</p><p>主要作用：延伸变量的作用范围</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> num = <span class="hljs-number">11</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;         <span class="hljs-comment">// fun这个函数作用域访问了另一个函数fn中的局部变量num，即产生了闭包</span>        <span class="hljs-built_in">console</span>.log(num); <span class="hljs-comment">// 11</span>    &#125;    fun();&#125;fn();</code></pre></div><p><img src="/blogImg/image-20200818222038219.png" srcset="/img/loading.gif" alt="image-20200818222038219"></p><h3 id="在外部作用域访问内部的局部变量"><a href="#在外部作用域访问内部的局部变量" class="headerlink" title="在外部作用域访问内部的局部变量"></a>在外部作用域访问内部的局部变量</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(num);    &#125;&#125;<span class="hljs-keyword">let</span> f = fn();f();<span class="hljs-comment">// 10</span></code></pre></div><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> car = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 局部变量</span>   <span class="hljs-keyword">let</span> start = <span class="hljs-number">13</span>;     <span class="hljs-comment">// 局部变量</span>   <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;   <span class="hljs-keyword">return</span> &#123;       price: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;           <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) &#123;               total = start;           &#125; <span class="hljs-keyword">else</span> &#123;               total = (n - <span class="hljs-number">3</span>) * <span class="hljs-number">5</span> + start           &#125;           <span class="hljs-keyword">return</span> total;       &#125;,       yd: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flag</span>) </span>&#123;           <span class="hljs-keyword">return</span> flag ? total + <span class="hljs-number">10</span> : total;       &#125;   &#125;&#125;)();car.price(<span class="hljs-number">5</span>); <span class="hljs-comment">// 23</span>car.yd(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 33</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>严格模式</title>
    <link href="/2020/08/18/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/18/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h3 id="什么是严格模式"><a href="#什么是严格模式" class="headerlink" title="什么是严格模式"></a>什么是严格模式</h3><p>严格模式（strict mode)，采用具有限制性的JavaScript用法，在严格的条件下运行JS代码。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol><li>消除了JavaScript语法中的一些不合理，不严谨之处，减少了一些怪异行为</li><li>消除了代码运行的一些不安全之处，保证代码运行的安全</li><li>提高编译器效率，增加运行速度</li><li>禁用了在ECMAScript的未来版本中可能会使用的一些语法</li></ol><h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><ul><li><p>为脚本开启严格模式</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta">    'use strict'</span>;</span><span class="actionscript">    <span class="hljs-comment">// 下方的代码将按照严格模式执行代码</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>// or<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span><span class="javascript"><span class="hljs-meta">  'use strict'</span>;</span><span class="actionscript">        <span class="hljs-comment">// ....</span></span>    &#125;)();<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li><li><p>为函数开启严格模式</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">'use strict'</span>;   <span class="hljs-comment">// 只给该函数开启严格模式</span>&#125;</code></pre></div></li></ul><h3 id="严格模式下的变化"><a href="#严格模式下的变化" class="headerlink" title="严格模式下的变化"></a>严格模式下的变化</h3><ol><li><p>变量必须先声明再使用</p></li><li><p>禁止删除已声明的变量</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">delete</span> a;<span class="hljs-comment">// ERROR</span></code></pre></div></li><li><p>this指向</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 严格模式下全局作用域中函数中的this指向undefined，而不是window</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// undefined</span>&#125;<span class="hljs-comment">// 构造函数不加new 调用，this会报错</span><span class="hljs-comment">// 定时器中this仍指向window</span><span class="hljs-comment">// 事件、对象还是指向调用者</span></code></pre></div></li><li><p>函数中不能有重名参数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, a</span>) </span>&#123;<span class="hljs-comment">// 严格模式下报错</span>    <span class="hljs-built_in">console</span>.log(a + a);<span class="hljs-comment">// 正常模式会输出4</span>&#125;fu(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre></div></li><li><p>不允许在非函数代码块中声明函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// ERROR</span>            &#125;&#125;</code></pre></div></li><li><p>……</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">MDN</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖与节流</title>
    <link href="/2020/08/18/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/2020/08/18/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h3><p>在事件被触发后n秒内再执行回调，如果在这段时间内再次触发，则重新开始计时</p><p>虽然知道概念，但是面试时让我写一个通用的防抖函数，有一点懵，下面贴代码：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fun, delay</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>&#123;        <span class="hljs-keyword">let</span> that = <span class="hljs-keyword">this</span>        <span class="hljs-keyword">let</span> _args = args        clearTimeout(fun.id);        fun.id = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            fun.call(that, _args)        &#125;, delay)    &#125;&#125;</code></pre></div><h3 id="函数节流（throttle"><a href="#函数节流（throttle" class="headerlink" title="函数节流（throttle)"></a>函数节流（throttle)</h3><p>在一个规定时间内，最多只能触发一次，即第一次触发后，至少间隔一个规定时间，才会触发第二次。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, interval = <span class="hljs-number">300</span></span>) </span>&#123;    <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>;        canRun = <span class="hljs-literal">false</span>;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);            canRun = <span class="hljs-literal">true</span>;        &#125;, interval);    &#125;;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts图表resize</title>
    <link href="/2020/08/17/ECharts%E5%9B%BE%E8%A1%A8resize%E4%BC%98%E5%8C%96/"/>
    <url>/2020/08/17/ECharts%E5%9B%BE%E8%A1%A8resize%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>在用户改变浏览器窗口大小或者侧边栏展开时，需要重新调整ECharts图表的大小，以适应窗口。</p><h2 id="监听方法"><a href="#监听方法" class="headerlink" title="监听方法"></a>监听方法</h2><p>ECharts有resize()方法，监听到变化时，调用该函数。</p><ol><li><p>对window的Resize事件进行监听</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-keyword">this</span>.chartResize);</code></pre></div><p>这样只能对浏览器窗口大小变化时进行监听，侧边栏展开时，窗口大小无变化，所以还需要对侧边栏状态等设置监听</p><div class="hljs"><pre><code class="hljs javascript">computed: &#123;   <span class="hljs-comment">// 侧边栏是否打开</span>   sideBarFlag: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.state.app.sidebar.opened   &#125;&#125;,watch: &#123;   <span class="hljs-comment">// 侧边栏展开收起状态变化时改变大小</span>   sideBarFlag: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">this</span>.chartResize()   &#125;&#125;</code></pre></div></li><li><p>单独对存放ECharts的DOM进行监听</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> ResizeObserver(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;   <span class="hljs-keyword">this</span>.myChart.resize()&#125;)resizeObserver.observe(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-keyword">this</span>.id))</code></pre></div><p>ResizeObserver的具体用法参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver" target="_blank" rel="noopener">MDN</a></p><p>由于直接对DOM大小进行监听，所以不用再对侧边栏变化等设置监听，但是IE浏览器不支持这个API</p></li></ol><h2 id="图表大小调整时的优化"><a href="#图表大小调整时的优化" class="headerlink" title="图表大小调整时的优化"></a>图表大小调整时的优化</h2><p>重绘会消耗较多的资源，如果监听到后立即进行重绘，可能会造成频繁重绘，造成页面卡顿。所以通过设置定时器，在一段时间内没有监听到变化后，再进行重绘</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 图表重绘方法</span>chartResize() &#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chartResizeTimer) &#123;     <span class="hljs-comment">// 先清除上个定时器</span>     clearTimeout(<span class="hljs-keyword">this</span>.chartResizeTimer)   &#125;   <span class="hljs-comment">// 设置定时器</span>   <span class="hljs-keyword">this</span>.chartResizeTimer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;     <span class="hljs-keyword">this</span>.myChart.resize()<span class="hljs-comment">// 进行重绘</span>   &#125;, <span class="hljs-number">300</span>)&#125;,</code></pre></div><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div    :id&#x3D;&quot;id&quot;    :style&#x3D;&quot;&#123;width: &#39;100%&#39;, height: &#39;100%&#39;&#125;&quot;  &gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import echarts from &#39;echarts&#39;export default &#123;  name: &#39;EChartsContainer&#39;,  props: &#123;    id: &#123;      type: String,      default: &#39;&#39;,    &#125;,    option: &#123;      type: Object,      default: () &#x3D;&gt; null,    &#125;,  &#125;,  data() &#123;    return &#123;      myChart: null,      chartResizeTimer: null,    &#125;  &#125;,  mounted() &#123;    this.myChart &#x3D; echarts.init(document.getElementById(this.id), &#39;light&#39;)    this.setOption()    &#x2F;&#x2F; 监听window的Resize    window.addEventListener(&#39;resize&#39;, this.chartResize)    &#x2F;&#x2F; 监听指定Dom的Resize,IE不支持    &#x2F;&#x2F; const resizeObserver &#x3D; new ResizeObserver(entries &#x3D;&gt; &#123;    &#x2F;&#x2F;   this.myChart.resize()    &#x2F;&#x2F; &#125;)    &#x2F;&#x2F; resizeObserver.observe(document.getElementById(this.id))  &#125;,  activated() &#123;    &#x2F;&#x2F; 切换标签页后resize    this.myChart.resize()  &#125;,  beforeDestoryed() &#123;    window.removeEventListener(&#39;resize&#39;, this.chartResize)  &#125;,  methods: &#123;    setOption() &#123;      this.myChart.setOption(this.option)    &#125;,    &#x2F;&#x2F; 图表大小调整，设置定时器避免频繁重绘    chartResize() &#123;      if (this.chartResizeTimer) &#123;        clearTimeout(this.chartResizeTimer)      &#125;      this.chartResizeTimer &#x3D; setTimeout(() &#x3D;&gt; &#123;        this.myChart.resize()      &#125;, 300)    &#125;,  &#125;,  computed: &#123;    &#x2F;&#x2F; 侧边栏是否打开    sideBarFlag: () &#x3D;&gt; &#123;      return this.$store.state.app.sidebar.opened    &#125;,  &#125;,  watch: &#123;    &#x2F;&#x2F; 监听option参数变化    option: function () &#123;      this.setOption()    &#125;,    &#x2F;&#x2F; 侧边栏展开收起状态变化时改变大小    sideBarFlag: function () &#123;      this.chartResize()    &#125;,  &#125;,&#125;&lt;&#x2F;script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ECharts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECharts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数与call,apply与bind的使用</title>
    <link href="/2020/08/16/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <url>/2020/08/16/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h2><ol><li><p>自定义函数（命名函数）</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</code></pre></div></li><li><p>函数表达式（匿名函数）</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</code></pre></div></li><li><p>使用<code>new Function(&#39;arg1&#39;, &#39;arg2&#39;, ... , &#39;函数体&#39;)</code></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'console.log(x + y)'</span>);<span class="hljs-comment">// 参数都是字符串形式</span>fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 输出 3</span></code></pre></div></li></ol><p>所有函数都是Function的实例（对象），函数也是对象，也有原型</p><div class="hljs"><pre><code class="hljs javascript">fun <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>;<span class="hljs-comment">// true</span>fun.__proto__.constructor === <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// true</span></code></pre></div><h2 id="函数的调用与this指向"><a href="#函数的调用与this指向" class="headerlink" title="函数的调用与this指向"></a>函数的调用与this指向</h2><ol><li><p>普通函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// this指向window</span>&#125;fun();<span class="hljs-comment">// == window.fun()</span></code></pre></div></li><li><p>对象的方法</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wuzi = &#123;    say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// this指向对象</span>    &#125;&#125;wuzi.say();</code></pre></div></li><li><p>构造函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数以及构造函数的原型对象中的this指向实例对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-keyword">let</span> wuzi = <span class="hljs-keyword">new</span> People();</code></pre></div></li><li><p>绑定事件函数</p><div class="hljs"><pre><code class="hljs javascript">btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 指向函数的调用者，即btn</span>&#125;;<span class="hljs-comment">// 点击触发</span></code></pre></div></li><li><p>定时器函数</p><div class="hljs"><pre><code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 指向window</span>&#125;, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 每隔一段时间调用一次</span></code></pre></div></li><li><p>立即执行函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 自动调用</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 指向window</span>&#125;)();</code></pre></div><h2 id="改变函数内部的this指向"><a href="#改变函数内部的this指向" class="headerlink" title="改变函数内部的this指向"></a>改变函数内部的this指向</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wuzi &#123;    name: <span class="hljs-string">'uzi'</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// wuzi</span>    <span class="hljs-built_in">console</span>.log(a + b);<span class="hljs-comment">// 3</span>&#125;;fun.call(wuzi, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// call调用函数，第一个参数改变函数内部this的指向，后面为函数的参数</span></code></pre></div><p>可以使用call实现继承功能</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-comment">// this 指向父构造函数的对象实例</span>    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;    <span class="hljs-comment">// this 指向子构造函数的对象实例</span>    Father.call(<span class="hljs-keyword">this</span>, name, age);    <span class="hljs-keyword">this</span>.sex = sex;&#125;</code></pre></div><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wuzi &#123;    name: <span class="hljs-string">'uzi'</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// wuzi</span>    <span class="hljs-built_in">console</span>.log(a + b);<span class="hljs-comment">// 3</span>&#125;;fun.apply(wuzi, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<span class="hljs-comment">// apply调用函数，第一个参数改变函数内部this的指向，参数必须以数组的形式传递</span></code></pre></div><p>应用</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, arr);<span class="hljs-comment">// 利用数学内置对象求最大值</span><span class="hljs-comment">// == Math.max.apply(Math, arr);</span><span class="hljs-comment">// == let max = Max.max(...arr);// 使用解构</span></code></pre></div><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wuzi &#123;    name: <span class="hljs-string">'uzi'</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// wuzi</span>    <span class="hljs-built_in">console</span>.log(a + b);<span class="hljs-comment">// 3</span>&#125;;<span class="hljs-keyword">let</span> newFun = fun.bind(wuzi, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 不会调用函数，返回改造完this后产生的新函数的拷贝</span>newFun(); <span class="hljs-comment">// 调用</span></code></pre></div><p>如果有的函数不需要立即调用，想要改变函数内部this指向，则应该使用bind</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 点击按钮后禁用按钮，3秒后恢复</span><span class="hljs-keyword">let</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'button'</span>);btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.disabled = <span class="hljs-literal">true</span>;<span class="hljs-comment">// this指向btn</span>    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">this</span>.disabled = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 绑定了btn, 否则this指向window</span>    &#125;.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">3000</span>)&#125;</code></pre></div><h3 id="相同点与区别"><a href="#相同点与区别" class="headerlink" title="相同点与区别"></a>相同点与区别</h3><p>相同点：都可以改变函数内部的指向</p><p>区别：</p><ul><li>call和apply会立即调用函数，bind不会调用</li><li>call和bind传递参数以逗号分隔，apply必须以将参数放在一个数组中</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造函数与原型</title>
    <link href="/2020/08/15/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/"/>
    <url>/2020/08/15/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>ES6前没有引入类的概念，使用构造函数与原型模拟类的实现。</p><h2 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h2><ol><li><p>使用<code>new Object()</code>创建对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();</code></pre></div></li><li><p>利用对象字面量创建对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;</code></pre></div></li><li><p>利用构造函数创建对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'永远滴神'</span>);    &#125;&#125;<span class="hljs-keyword">let</span> uzi = <span class="hljs-keyword">new</span> People(<span class="hljs-string">'乌兹'</span>, <span class="hljs-number">18</span>);uzi.say();</code></pre></div></li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数用来初始化对象，即为对象成员变量赋初始值，总是与new一起使用</p><h3 id="new在执行时做的四件事"><a href="#new在执行时做的四件事" class="headerlink" title="new在执行时做的四件事"></a>new在执行时做的四件事</h3><ol><li>在内存中创建一个新的空对象</li><li>让this指向这个新的对象</li><li>执行构造函数中的代码，给这个新的对象添加属性和方法</li><li>返回这个新对象（所有构造函数中不需要return）</li></ol><h3 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h3><ul><li>静态成员：在构造函数本身上添加的成员</li><li>实例成员：构造函数内部通过this添加的成员，只能通过实例化的对象来访问</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'永远滴神'</span>);    &#125;&#125;<span class="hljs-comment">// name,age,say为实例成员</span><span class="hljs-keyword">let</span> uzi = <span class="hljs-keyword">new</span> People(<span class="hljs-string">'乌兹'</span>, <span class="hljs-number">18</span>);uzi.say();<span class="hljs-comment">// 静态成员,只能通过构造函数访问</span>People.sex = <span class="hljs-string">"男"</span> <span class="hljs-built_in">console</span>.log(People.sex);<span class="hljs-comment">// 男</span><span class="hljs-built_in">console</span>.log(uzi.sex);<span class="hljs-comment">// undefined</span></code></pre></div><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="构造函数原型对象prototype"><a href="#构造函数原型对象prototype" class="headerlink" title="构造函数原型对象prototype"></a>构造函数原型对象prototype</h3><p>构造函数存在浪费内存的问题，每new一个对象就会开辟新的内存空间存放参数和方法</p><p>使用原型来解决这个问题</p><p>JavaScript规定，每个构造函数都有一个prototype属性，指向另一个对象，这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有，构造函数通过原型分配的函数是所有对象所共享的</p><p>可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 一般情况下，公共属性定义到构造函数里，公共方法放到原型对象上</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;People.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'永远滴神'</span>)    <span class="hljs-comment">// 这里的this也指向实例对象</span>&#125;<span class="hljs-keyword">let</span> uzi = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"wuzi"</span>, <span class="hljs-number">18</span>);<span class="hljs-keyword">let</span> theShy = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"shy"</span>, <span class="hljs-number">12</span>);uzi.say === theShy.say;<span class="hljs-comment">// true, 内存位置相同</span></code></pre></div><h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto__"></a>对象原型<code>__proto__</code></h3><p>对象都会有一个属性<code>__proto__</code>指向构造函数的prototype原型对象，之所以对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有<code>__proto__</code>原型的存在</p><div class="hljs"><pre><code class="hljs javascript">uzi.__proto__ = People.prototype</code></pre></div><h3 id="原型constructor"><a href="#原型constructor" class="headerlink" title="原型constructor"></a>原型constructor</h3><p>对象原型和原型对象中都有一个constructor属性，用于记录对象引用哪个构造函数</p><p>很多情况下，手动的利用constructor属性指回原来的构造函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;People.prototype = &#123;    <span class="hljs-comment">// 如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor指回原来的构造函数</span>    <span class="hljs-keyword">constructor</span>: People,    say: function() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'111'</span>);    &#125;    run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'222'</span>);    &#125;&#125;</code></pre></div><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="/blogImg/proto.drawio.png" srcset="/img/loading.gif" alt="proto.drawio"></p><p>只要是对象就有<code>__proto__</code>原型，Object原型对象中的<code>__proto__</code>指向null，为最上层</p><p>方法查找规则：首先看对象本身是否有say方法，如果有就执行该方法，如果没有，因为存在<code>__proto__</code>，就去构造函数原型对象prototype中查找该方法，通过原型链一层层向上查找。</p><h3 id="拓展内置对象方法"><a href="#拓展内置对象方法" class="headerlink" title="拓展内置对象方法"></a>拓展内置对象方法</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;        sum+=<span class="hljs-keyword">this</span>[i];    &#125;    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-built_in">console</span>.log(arr.sum());<span class="hljs-comment">// 6</span></code></pre></div><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES6前没有提供extends属性提供继承功能，通过构造函数+原型对象模拟继承</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 借用父构造函数继承属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-comment">// this 指向父构造函数的对象实例</span>    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;Father.prototype.money = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">10000</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;    <span class="hljs-comment">// this 指向子构造函数的对象实例</span>    Father.call(<span class="hljs-keyword">this</span>, name, age);    <span class="hljs-keyword">this</span>.sex = sex;&#125;<span class="hljs-comment">// Son.prototype = Father.prototype; 这样指向同一个地址，修改子原型对象后，父原型对象也会被修改</span>Son.prototype = <span class="hljs-keyword">new</span> Father();<span class="hljs-comment">// 利用对象覆盖原有的原型对象后，要将constructor指回原来的构造函数</span>Son.prototype.constructor = Son;Son.prototype.exam = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"exam"</span>);&#125;<span class="hljs-keyword">let</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'wuzi'</span>, <span class="hljs-number">18</span>, <span class="hljs-string">'男'</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS面向对象编程</title>
    <link href="/2020/08/14/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/08/14/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h2><p>面向过程编程POP（Process-oriented programming）：分析出解析问题所需要的步骤，然后用函数把这些步骤一步步实现，使用的时候在一个一个一次调用。</p><p>面向对象编程OOP（Object Oriented Programming）：面向对象是把事务分解成为一个个对象，然后由对象之间分工合作。以对象功能来划分问题，而不是步骤。</p><p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点</p><p>特性：</p><ul><li>封装性</li><li>继承性</li><li>多态性</li></ul><p>思维特点：</p><p>1、抽取（抽象）对象共有的属性和行为组织（封装）成一个类（模板）</p><p>2、对对象进行实例化，获取类的对象</p><p>在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象</p><ul><li>属性：事物的特征</li><li>方法：事物的行为</li></ul><h2 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h2><p>在ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化一个对象。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<span class="hljs-comment">// 类的共有属性放在constructor中</span>    <span class="hljs-keyword">constructor</span>(name) &#123;        <span class="hljs-keyword">this</span>.name = name;<span class="hljs-comment">// this指向创建的实例对象</span>    &#125;    <span class="hljs-comment">// 方法</span>    say(text) &#123;        <span class="hljs-comment">// 方法中的this指向方法的调用者</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + text);    &#125;&#125;<span class="hljs-comment">// 利用类创建对象</span><span class="hljs-keyword">let</span> uzi = <span class="hljs-keyword">new</span> People(<span class="hljs-string">'乌兹'</span>);<span class="hljs-built_in">console</span>.log(uzi.name);<span class="hljs-comment">// '乌兹'</span>uzi.say(<span class="hljs-string">"永远滴神！"</span>);<span class="hljs-comment">// 乌兹永远的神!</span></code></pre></div><ul><li>通过class关键字创建类，类名习惯大写</li><li>类中有一个constructor函数，可以接受传递过来的参数，同时返回实例对象</li><li>constructor函数 只要new生成实例时，就会自动调用，如果不写这个函数，类也会自动生成这个函数</li><li>生成实例new不能省略</li><li>创建类，类名后不要加小括号，构造函数不需要加function</li><li>ES6中类没有变量提升，必须先定义类，才能通过类实例化对象</li><li>类里的共有属性和方法一定要加this使用</li></ul><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(x,y) &#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    money() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">100</span>);    &#125;    sum() &#123;<span class="hljs-comment">// 父类方法必须使用父类中的参数</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y);    &#125;    say() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"小头爸爸"</span>);    &#125;&#125;<span class="hljs-comment">// 子类继承父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(x,y) &#123;        <span class="hljs-comment">// 调用了父类的构造函数</span>        <span class="hljs-keyword">super</span>(x,y)        <span class="hljs-comment">// super必须在子类this之前调用</span>        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    say() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"大头儿子"</span>);    &#125;    fatherSay() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">super</span>.say());<span class="hljs-comment">// 调用父类的函数</span>    &#125;&#125;<span class="hljs-keyword">let</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// 继承中，如果实例化子类输出一个方法，先看看子类有没有这个方法，如果有先执行子类的，如果没有就去查找父类（就近原则）</span>son.money(); <span class="hljs-comment">// 100</span>son.sum(); <span class="hljs-comment">// 3</span>son.say(); <span class="hljs-comment">// 大头儿子</span>son.fatherSay(); <span class="hljs-comment">// 小头爸爸</span></code></pre></div><h2 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h2><p>类的本质还是一个函数，可以认为类就是构造函数的另外一种写法</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    &#125;<span class="hljs-keyword">typeof</span> People; <span class="hljs-comment">// function</span></code></pre></div><ol><li><p>类有原型对象</p><div class="hljs"><pre><code class="hljs javascript">People.prototype;</code></pre></div></li><li><p>类的原型对象中的构造函数指向类本身</p><div class="hljs"><pre><code class="hljs javascript">People.prototype.constructor === <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;&#125;</code></pre></div></li><li><p>类可以通过原型对象添加方法</p><div class="hljs"><pre><code class="hljs javascript">People.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'112'</span>);&#125;</code></pre></div></li><li><p>类创建的实例中也有对象原型<code>__proto__</code>，指向类的原型对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> uzi = <span class="hljs-keyword">new</span> People();uzi.__proto__ === People.prototype;</code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6中Set的使用</title>
    <link href="/2020/08/12/ES6%E4%B8%ADSet%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/12/ES6%E4%B8%ADSet%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>Set</code>对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会<strong>出现一次</strong>，即 Set 中的元素是唯一的。</p><p><code>NaN</code>和<code>undefined</code>都可以被存储在Set 中， <code>NaN</code>之间被视为相同的值（NaN被认为是相同的，尽管 NaN !== NaN）。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="创建一个Set对象"><a href="#创建一个Set对象" class="headerlink" title="创建一个Set对象"></a>创建一个Set对象</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 空Set</span><span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<span class="hljs-comment">// 接收具有iterable接口的数据结构作为参数</span><span class="hljs-keyword">let</span> mySet1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>])<span class="hljs-comment">// 1,2,3</span><span class="hljs-keyword">let</span> mySet2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">'abbcccd'</span>)<span class="hljs-comment">// a,b,c</span></code></pre></div><p><img src="/blogImg/image-20200812181010595.png" srcset="/img/loading.gif" alt="image-20200812181010595"></p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 值为整数，表示Set对象中有多少条目</span>mySet1.size() <span class="hljs-comment">// 3</span></code></pre></div><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加一个值</span>mySet.add(value);<span class="hljs-comment">// 可以链式调用</span>mySet.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>);</code></pre></div><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 返回一个布尔值来指示对应的值value是否存在Set对象中</span>mySet.has(value);</code></pre></div><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 清空Set</span>mySet.clear();</code></pre></div><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();mySet.add(<span class="hljs-string">"foo"</span>);mySet.delete(<span class="hljs-string">"bar"</span>); <span class="hljs-comment">// 返回 false，不包含 "bar" 这个元素</span>mySet.delete(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// 返回 true，删除成功</span>mySet.has(<span class="hljs-string">"foo"</span>);    <span class="hljs-comment">// 返回 false，"foo" 已经成功删除</span></code></pre></div><h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><p>entries() 方法返回一个新的迭代器对象 ，这个对象的元素是类似 [value, value] 形式的数组，value 是集合对象中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序。由于集合对象不像 Map 对象那样拥有 key，然而，为了与 Map 对象的 API 形式保持一致，故使得每一个 entry 的 key 和 value 都拥有相同的值，因而最终返回一个 [value, value] 形式的数组。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();mySet.add(<span class="hljs-string">"foobar"</span>);mySet.add(<span class="hljs-number">1</span>);mySet.add(<span class="hljs-string">"baz"</span>);<span class="hljs-keyword">var</span> setIter = mySet.entries();<span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// ["foobar", "foobar"]</span><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// [1, 1]</span><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// ["baz", "baz"]</span></code></pre></div><h3 id="keys-values"><a href="#keys-values" class="headerlink" title="keys / values"></a>keys / values</h3><p> Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet.keys()) &#123;  <span class="hljs-built_in">console</span>.log(item);&#125;<span class="hljs-comment">// a</span><span class="hljs-comment">// b</span><span class="hljs-comment">// c</span><span class="hljs-keyword">let</span> setIter = mySet.keys() <span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// "a"</span><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// "b"</span><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// "b"</span></code></pre></div><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">Set</span>.prototype[<span class="hljs-built_in">Symbol</span>.iterator] === <span class="hljs-built_in">Set</span>.prototype.values<span class="hljs-comment">// true</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> mySet) &#123;    <span class="hljs-built_in">console</span>.log(x);&#125;</code></pre></div><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Set 结构的实例与数组一样，<code>forEach</code>方法会依次为集合中的元素执行回调函数，没有返回值。</p><p><strong>回调函数</strong>有三个参数:</p><ul><li>元素的值</li><li>元素的索引</li><li>正在遍历的集合对象</li></ul><p>其中值与索引相同</p><div class="hljs"><pre><code class="hljs javascript">mySet.forEach(<span class="hljs-function">(<span class="hljs-params">value, key, myset</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">' : '</span> + value)&#125;)</code></pre></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="数组、字符串去重"><a href="#数组、字符串去重" class="headerlink" title="数组、字符串去重"></a>数组、字符串去重</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]);<span class="hljs-keyword">let</span> arr = [...set];</code></pre></div><h3 id="交集、并集、差集"><a href="#交集、并集、差集" class="headerlink" title="交集、并集、差集"></a>交集、并集、差集</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);<span class="hljs-comment">// 并集</span><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a, ...b]);<span class="hljs-comment">// Set &#123;1, 2, 3, 4&#125;</span><span class="hljs-comment">// 交集</span><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> b.has(x)));<span class="hljs-comment">// set &#123;2, 3&#125;</span><span class="hljs-comment">// （a 相对于 b 的）差集</span><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !b.has(x)));<span class="hljs-comment">// Set &#123;1&#125;</span></code></pre></div><h3 id="更改原来的Set结构"><a href="#更改原来的Set结构" class="headerlink" title="更改原来的Set结构"></a>更改原来的Set结构</h3><p>目前没有直接办法改变原有的Set结构</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法一</span><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> = new Set([1, 2, 3]);<span class="hljs-keyword">set</span> = new Set([...<span class="hljs-keyword">set</span>].map(val =&gt; val * 2));// <span class="hljs-keyword">set</span>的值是2, 4, 6// 方法二let <span class="hljs-keyword">set</span> = new Set([1, 2, 3]);<span class="hljs-keyword">set</span> = new Set(Array.from(<span class="hljs-keyword">set</span>, val =&gt; val * 2));// <span class="hljs-keyword">set</span>的值是2, 4, 6</code></pre></div><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet的成员只能是对象，不能是其他类型的值。</p><p>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/set-map</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索与广度优先搜索</title>
    <link href="/2020/08/12/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2020/08/12/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> board = [    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>],    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>],    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>],    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>]]</code></pre></div><p>运行你的函数后，矩阵变为：</p><div class="hljs"><pre><code class="hljs javascript">board = [    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>],    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>],    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>],    [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>]]</code></pre></div><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/surrounded-regions" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surrounded-regions</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出所有边界上的’O’，并从边界上的’O’开始寻找相邻的’O’</p><ul><li>对于每一个边界上的 O，以它为起点，标记所有与它直接或间接相连的字母 O；</li><li>最后遍历这个矩阵，对于每一个字母：<ul><li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；</li><li>如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li></ul></li></ul><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> row, col = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solve</span>(<span class="hljs-params">board</span>) </span>&#123;    <span class="hljs-keyword">if</span> (board == <span class="hljs-literal">null</span> || board.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    row = board.length;    col = board[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; col; c++) &#123;<span class="hljs-comment">// 对矩阵的第一行与最后一行进行遍历</span>        dfs(board, <span class="hljs-number">0</span>, c);        dfs(board, row - <span class="hljs-number">1</span>, c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = <span class="hljs-number">1</span>; r &lt; row - <span class="hljs-number">1</span>; r++) &#123;<span class="hljs-comment">// 对矩阵的第一列与最后一列进行遍历（排除前一个for循环中包含的端点）</span>        dfs(board, r, <span class="hljs-number">0</span>);        dfs(board, r, col - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<span class="hljs-comment">// 深度优先搜索结束后，遍历矩阵，将为'O'的置为'X',将标记过的值还原为'O'</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;            board[i][j] === <span class="hljs-string">"O"</span> &amp;&amp; (board[i][j] = <span class="hljs-string">"X"</span>);            board[i][j] === <span class="hljs-string">"Y"</span> &amp;&amp; (board[i][j] = <span class="hljs-string">"O"</span>);        &#125;    &#125;&#125;;<span class="hljs-comment">// 深度优先搜索</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">board, x, y</span>) </span>&#123;<span class="hljs-comment">// 判断是否越界，矩阵值是否为'O'</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= row || y &gt;= col || board[x][y] != <span class="hljs-string">"O"</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 满足条件，进行标记</span>    board[x][y] = <span class="hljs-string">"Y"</span>;    <span class="hljs-comment">// 对其四周的值进行深度优先搜索</span>    dfs(board, x + <span class="hljs-number">1</span>, y);    dfs(board, x, y + <span class="hljs-number">1</span>);    dfs(board, x, y - <span class="hljs-number">1</span>);    dfs(board, x - <span class="hljs-number">1</span>, y);&#125;</code></pre></div><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> row, col = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solve</span>(<span class="hljs-params">board</span>) </span>&#123;    <span class="hljs-keyword">const</span> dx = [<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];    <span class="hljs-keyword">const</span> dy = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>];    <span class="hljs-keyword">if</span> (board == <span class="hljs-literal">null</span> || board.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    row = board.length;    col = board[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">let</span> quene = [];<span class="hljs-comment">// 初始化队列</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; col; c++) &#123;<span class="hljs-comment">// 首行与末行</span>        <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][c] === <span class="hljs-string">"O"</span>) &#123;            quene.push([<span class="hljs-number">0</span>, c])<span class="hljs-comment">// 放入队列</span>        &#125;        <span class="hljs-keyword">if</span> (board[row - <span class="hljs-number">1</span>][c] === <span class="hljs-string">"O"</span>) &#123;            quene.push([row - <span class="hljs-number">1</span>, c])        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = <span class="hljs-number">1</span>; r &lt; row - <span class="hljs-number">1</span>; r++) &#123;<span class="hljs-comment">// 首列与末列</span>        <span class="hljs-keyword">if</span> (board[r][<span class="hljs-number">0</span>] === <span class="hljs-string">"O"</span>) &#123;            quene.push([r, <span class="hljs-number">0</span>])        &#125;        <span class="hljs-keyword">if</span> (board[r][col - <span class="hljs-number">1</span>] === <span class="hljs-string">"O"</span>) &#123;            quene.push([r, col - <span class="hljs-number">1</span>])        &#125;    &#125;    <span class="hljs-keyword">while</span> (quene.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 循环直至队列为空</span>        <span class="hljs-keyword">let</span> x = quene[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">let</span> y = quene[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        quene.shift();<span class="hljs-comment">// 移出队列</span>        board[x][y] = <span class="hljs-string">"Y"</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-comment">// 将当前位置四周为'O'的坐标放入队列中</span>            <span class="hljs-keyword">let</span> mx = x + dx[i];            <span class="hljs-keyword">let</span> my = y + dy[i];            <span class="hljs-keyword">if</span> (mx &lt; <span class="hljs-number">0</span> || my &lt; <span class="hljs-number">0</span> || mx &gt;= row || my &gt;= col || board[mx][my] != <span class="hljs-string">"O"</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            quene.push([mx, my])        &#125;    &#125;<span class="hljs-comment">// 广度优先搜索结束后，遍历矩阵，将为'O'的置为'X',将标记过的值还原为'O'</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;            board[i][j] === <span class="hljs-string">"O"</span> &amp;&amp; (board[i][j] = <span class="hljs-string">"X"</span>);            board[i][j] === <span class="hljs-string">"Y"</span> &amp;&amp; (board[i][j] = <span class="hljs-string">"O"</span>);        &#125;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6中Map的使用</title>
    <link href="/2020/08/10/JavaScript%E4%B8%ADMap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/10/JavaScript%E4%B8%ADMap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Map的概念"><a href="#Map的概念" class="headerlink" title="Map的概念"></a>Map的概念</h2><p>JS的对象只能以字符串或是Symbol作为键值，在ES6规范中引入了Map对象保存键值对，任何值(对象或者<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive" target="_blank" rel="noopener">原始值</a>) 都可以作为一个键或一个值，并且能够记住键的原始插入顺序。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-comment">// 初始化一个空Map</span><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'张三'</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">'李四'</span>, <span class="hljs-number">2</span>]]);<span class="hljs-comment">// 初始值</span></code></pre></div><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>一个 <code>Map</code>的键可以是<strong>任意值</strong>，包括函数、对象或任意基本类型</li><li><code>Map</code> 中的 key 是有序的。因此，当迭代的时候，一个 <code>Map</code> 对象以插入的顺序返回键值</li><li><code>Map</code> 的键值对个数可以轻易地通过size属性获取</li><li><code>Map</code> 是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable" target="_blank" rel="noopener">iterable</a> 的，所以可以直接被迭代</li><li>在频繁增删键值对的场景下表现更好</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//返回 一个Map 对象的成员数量</span>myMap.size; <span class="hljs-comment">// 2</span></code></pre></div><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.get(key);</span><span class="hljs-comment">// 返回某个Map对象中的一个指定元素，键不存在时返回undefined</span>myMap.get(<span class="hljs-string">'张三'</span>);<span class="hljs-comment">// 1</span></code></pre></div><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.set(key, value); </span><span class="hljs-comment">// 添加新的键值对,返回Map对象本身</span>myMap.set(<span class="hljs-string">'张三'</span>, <span class="hljs-number">18</span>);<span class="hljs-comment">// 键已存在时会被覆盖</span>myMap.set(<span class="hljs-string">'张三'</span>, <span class="hljs-number">30</span>);myMap.get(<span class="hljs-string">'张三'</span>); <span class="hljs-comment">// 30</span><span class="hljs-comment">// 因为Set()方法返回Map对象本身，可以使用链式写法</span>myMap.set(<span class="hljs-string">'李四'</span>, <span class="hljs-number">19</span>).set(<span class="hljs-string">"王五"</span>, <span class="hljs-number">20</span>);</code></pre></div><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.has(key);</span><span class="hljs-comment">// 返回一个bool值，用来表明map 中是否存在指定元素</span>myMap.has(<span class="hljs-string">'张三'</span>); <span class="hljs-comment">// true</span>myMap.has(<span class="hljs-string">'乌兹'</span>); <span class="hljs-comment">// false</span></code></pre></div><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.clear();</span><span class="hljs-comment">// 移除Map对象中的所有元素，返回undefined</span>myMap.clear();</code></pre></div><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.delete(key);</span><span class="hljs-comment">// 移除 Map 对象中指定的元素, 如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false</span>myMap.set(<span class="hljs-string">'wuzi'</span>, <span class="hljs-string">'RNG'</span>);myMap.delete(<span class="hljs-string">'wuzi'</span>);<span class="hljs-comment">// true</span>myMap.has(<span class="hljs-string">'wuzi'</span>); <span class="hljs-comment">// false</span></code></pre></div><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.forEach(callback[, thisArg])</span><span class="hljs-comment">// callback 必要，每个元素所要执行的函数, callback包含三个参数,value - 元素的值,key - 元素的键,Map - 当前正在被遍历的对象</span><span class="hljs-comment">// thisArg 可选，callback 执行时其 this 的值</span><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">"foo"</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">"bar"</span>, &#123;&#125;], [<span class="hljs-string">"baz"</span>, <span class="hljs-literal">undefined</span>]]);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logMapElements</span>(<span class="hljs-params">value, key, map</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"m["</span> + key + <span class="hljs-string">"] = "</span> + value);&#125;myMap.forEach(logMapElements);<span class="hljs-comment">// or</span>myMap.forEach(<span class="hljs-function">(<span class="hljs-params">value, key, map</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"m["</span> + key + <span class="hljs-string">"] = "</span> + value);&#125;)<span class="hljs-comment">// logs:</span><span class="hljs-comment">// "m[foo] = 3"</span><span class="hljs-comment">// "m[bar] = [object Object]"</span><span class="hljs-comment">// "m[baz] = undefined"</span></code></pre></div><p><code>forEach</code> 函数处理的元素的范围为第一次执行 callback 函数时 Map 对象中的键值对集合。在 <code>Map</code> 对象调用 <code>forEach</code> 之后加入的元素将不会被调用 <code>callback</code> 函数。如果在调用 <code>forEach</code> 之后 <code>Map</code> 对象中的被改变或者删除了，它们传给 <code>callback</code> 函数的值将会变成 <code>forEach</code> 函数访问它们时的值；<code>callback</code> 不会访问其调用其间被删除的元素。</p><h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.entries()</span><span class="hljs-comment">// 返回一个新的包含 [key, value] 对的 Iterator 对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同</span><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">"wuzi"</span>], [<span class="hljs-string">"2"</span>, <span class="hljs-string">"jacky"</span>]]);<span class="hljs-keyword">const</span> myIterator = myMap.entires();myIterator.next().value; <span class="hljs-comment">// [1, "wuzi"]</span>myIterator.next().value; <span class="hljs-comment">// ["2", "jacky"]</span></code></pre></div><p><img src="/blogImg/image-20200810225848337.png" srcset="/img/loading.gif" alt="image-20200810225848337"></p><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.keys()</span><span class="hljs-comment">// 返回一个引用的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的key值</span><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">"wuzi"</span>], [<span class="hljs-string">"2"</span>, <span class="hljs-string">"jacky"</span>]]);<span class="hljs-keyword">const</span> myIterator = myMap.keys();myIterator.next().value; <span class="hljs-comment">// 1</span>myIterator.next().value; <span class="hljs-comment">// "2"</span></code></pre></div><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// myMap.values()</span><span class="hljs-comment">// 返回一个新的Iterator对象。它包含按顺序插入Map对象中每个元素的value值</span></code></pre></div><h3 id="iterator"><a href="#iterator" class="headerlink" title="@@iterator"></a>@@iterator</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator</a></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// for .. of</span>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">"zero"</span>);myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> myMap) &#123;  <span class="hljs-built_in">console</span>.log(item);&#125;<span class="hljs-comment">// [ 0, zero ]</span><span class="hljs-comment">// [ 1, one ]</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">" = "</span> + value);&#125;<span class="hljs-comment">// 0 = zero</span><span class="hljs-comment">// 1 = one</span></code></pre></div><p>只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><p><img src="/blogImg/image-20200813114349457.png" srcset="/img/loading.gif" alt="image-20200813114349457"></p><h2 id="复制、合并、与数组的关系"><a href="#复制、合并、与数组的关系" class="headerlink" title="复制、合并、与数组的关系"></a>复制、合并、与数组的关系</h2><h3 id="复制Map"><a href="#复制Map" class="headerlink" title="复制Map"></a>复制Map</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> original = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-number">1</span>, <span class="hljs-string">'one'</span>]]);<span class="hljs-keyword">let</span> clone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(original);<span class="hljs-built_in">console</span>.log(clone.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// one</span><span class="hljs-built_in">console</span>.log(original === clone); <span class="hljs-comment">// false. 浅比较 不为同一个对象的引用</span></code></pre></div><h3 id="合并Map"><a href="#合并Map" class="headerlink" title="合并Map"></a>合并Map</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> first = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-number">1</span>, <span class="hljs-string">'one'</span>],  [<span class="hljs-number">2</span>, <span class="hljs-string">'two'</span>],  [<span class="hljs-number">3</span>, <span class="hljs-string">'three'</span>],]);<span class="hljs-keyword">let</span> second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-number">1</span>, <span class="hljs-string">'uno'</span>],  [<span class="hljs-number">2</span>, <span class="hljs-string">'dos'</span>]]);<span class="hljs-comment">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span><span class="hljs-comment">// 展开运算符本质上是将Map对象转换成数组。</span><span class="hljs-keyword">let</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([...first, ...second]);<span class="hljs-built_in">console</span>.log(merged.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// uno</span><span class="hljs-built_in">console</span>.log(merged.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// dos</span><span class="hljs-built_in">console</span>.log(merged.get(<span class="hljs-number">3</span>)); <span class="hljs-comment">// three</span></code></pre></div><h3 id="Map与数组的关系"><a href="#Map与数组的关系" class="headerlink" title="Map与数组的关系"></a>Map与数组的关系</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> kvArray = [[<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>], [<span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>]];<span class="hljs-comment">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(kvArray);myMap.get(<span class="hljs-string">"key1"</span>); <span class="hljs-comment">// 返回值为 "value1"</span><span class="hljs-comment">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(myMap)); <span class="hljs-comment">// 输出和kvArray相同的数组</span><span class="hljs-comment">// 更简洁的方法来做如上同样的事情，使用展开运算符</span><span class="hljs-built_in">console</span>.log([...myMap]);<span class="hljs-comment">// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(myMap.keys())); <span class="hljs-comment">// 输出 ["key1", "key2"]</span><span class="hljs-comment">// 与数组合并</span><span class="hljs-keyword">let</span> first = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-number">1</span>, <span class="hljs-string">'one'</span>],  [<span class="hljs-number">2</span>, <span class="hljs-string">'two'</span>],  [<span class="hljs-number">3</span>, <span class="hljs-string">'three'</span>],]);<span class="hljs-keyword">let</span> second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-number">1</span>, <span class="hljs-string">'uno'</span>],  [<span class="hljs-number">2</span>, <span class="hljs-string">'dos'</span>]]);<span class="hljs-comment">// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。</span><span class="hljs-keyword">let</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([...first, ...second, [<span class="hljs-number">1</span>, <span class="hljs-string">'eins'</span>]]);<span class="hljs-built_in">console</span>.log(merged.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// eins</span><span class="hljs-built_in">console</span>.log(merged.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// dos</span><span class="hljs-built_in">console</span>.log(merged.get(<span class="hljs-number">3</span>)); <span class="hljs-comment">// three</span></code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在做一道简单题时想用map，结果却忘了怎么使用，然后使用对象保存再for..in遍历的方式解决。</p><p>小明是个马大哈，某天他到超市买了若干双筷子（n&lt;20），筷子的长度不尽相同，他把全部筷子都放在购物袋里面拿回家，路上不小心漏了一根<br>请你用程序帮他找出是漏掉的筷子是多长</p><p>输入： 剩下的筷子数组，如：1, 2, 3, 2, 1, 3, 2</p><p>返回值：漏掉的筷子长度，如上述输入返回：2（当输入的筷子数据异常时返回-1，如：找不到漏掉的筷子）</p><p>其实就是找数量为单数的值</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSingle</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!arr) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        myMap.set(item, !myMap.has(item)); <span class="hljs-comment">// 单数为true, 复数为false</span>    &#125;)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;        <span class="hljs-keyword">if</span> (value) &#123;            <span class="hljs-keyword">return</span> key;        &#125;    &#125;&#125;<span class="hljs-comment">// or</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSingle</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!arr) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(myMap.has(item)) &#123;            myMap.delete(item);        &#125; <span class="hljs-keyword">else</span> &#123;            myMap.set(item, <span class="hljs-literal">true</span>);        &#125;    &#125;)    <span class="hljs-keyword">const</span> myIterator = myMap.keys();    <span class="hljs-keyword">return</span> myIterator.next().value;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]<span class="hljs-built_in">console</span>.log(findSingle(arr))<span class="hljs-comment">// 5</span></code></pre></div><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><a href="https://juejin.im/post/6844903646623186958" target="_blank" rel="noopener">https://juejin.im/post/6844903646623186958</a></p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue项目搭建</title>
    <link href="/2020/08/06/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/06/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>使用Vue-cli脚手架搭建一个项目。</p><h2 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h2><p>首先需要安装node，配置npm环境，Vue CLI 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 8.9 或更高版本</p><p>安装vue-cli脚手架</p><div class="hljs"><pre><code class="hljs bash">npm install -g @vue/cli<span class="hljs-comment"># OR</span>yarn global add @vue/cli</code></pre></div><p>之前安装过旧版本的话可以使用如下命令删除</p><div class="hljs"><pre><code class="hljs bash">npm uninstall -g vue-cli</code></pre></div><p>使用如下命令检查版本</p><div class="hljs"><pre><code class="hljs bash">vue --version</code></pre></div><p><img src="/blogImg/image-20200806201104552.png" srcset="/img/loading.gif" alt="image-20200806201104552"></p><p>安装过程可能比较久</p><h3 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h3><p>打开cmd命令行，进入需要创建项目的目录下，输入：</p><div class="hljs"><pre><code class="hljs bash">vue create [项目名]</code></pre></div><p>会进入到如下页面：</p><p><img src="/blogImg/image-20200806201320199.png" srcset="/img/loading.gif" alt="image-20200806201320199"></p><p>注意：使用gitBash貌似无法在此步骤进行选择，可以使用windows或者VSCode中自带的控制台</p><p>default包含了基本的 Babel + ESLint 设置，而手动设置则提供了更多的选项，这里进入手动设置</p><p><img src="/blogImg/image-20200806201624878.png" srcset="/img/loading.gif" alt="image-20200806201624878"></p><p>可选项包括：</p><ul><li><p>babel：JavaScript 编译器，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。<a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener">中文文档</a></p></li><li><p>TypeScript：JavaScript的超集 </p></li><li><p>Progressive Web App (PWA) Support：渐进式网页应用，还没了解过</p></li><li><p>Router：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">Vue Router </a> 官方的路由管理器</p></li><li><p>Vuex：Vue状态管理模式 <a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">官网</a></p></li><li><p>CSS Rre-processors：CSS 预处理，SASS，LESS和Stylus</p></li><li><p>Linter / Formatter：代码风格检查和格式化</p></li><li><p>Unit Testing：单元测试</p></li><li><p>E2E Testing：端到端测试</p></li></ul><p>根据需求选择更详细的配置：</p><p>​      <img src="/blogImg/image-20200806210603357.png" srcset="/img/loading.gif" alt="image-20200806210603357"></p><p>安装完成后输入：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> [项目名]yarn serve <span class="hljs-comment"># or</span>npm run serve</code></pre></div><p>在浏览器中即可看到，项目成功启动</p><p><img src="/blogImg/image-20200806211242163.png" srcset="/img/loading.gif" alt="image-20200806211242163"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题整理</title>
    <link href="/2020/08/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2020/08/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在这里记录下面试碰到的以及可能碰到的题目，用于复习巩固，查漏补缺。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>根据内容的结构，选择合适的标签</p><ol><li>方便代码的阅读和维护，在没有CSS的情况下也能呈现较好的内容结构</li><li>有利于SEO，让浏览器或是网络爬虫可以很好的解析，从而更好的分析其中的内容</li><li>使用语义化标签会具有更好的搜索引擎优化</li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="https://juejin.im/post/6844903495108132877" target="_blank" rel="noopener">https://juejin.im/post/6844903495108132877</a></p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="严格模式的作用"><a href="#严格模式的作用" class="headerlink" title="严格模式的作用"></a>严格模式的作用</h3><p><code>&quot;use strict&quot;;</code> 使代码脱离稀松模式（sloppy），对JavaScript语义做了一些更改：</p><ol><li>通过<strong>抛出错误</strong>来消除了一些原有<strong>静默错误</strong>，变量必须先声明在使用，禁用with等</li><li>消除了代码运行的一些不安全之处，保证代码运行的安全，禁用delete删除变量</li><li>提高编译器效率，增加运行速度</li><li>禁用了在ECMAScript的未来版本中可能会定义的一些语法</li></ol><p>全局作用域函数中this指向undefined，而不是window</p><p><a href="https://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">详见</a></p><h3 id="JS的基本数据类型"><a href="#JS的基本数据类型" class="headerlink" title="JS的基本数据类型"></a>JS的基本数据类型</h3><ul><li>基本类型：String、Number、Boolean、Symbol、Undefined、Null、（BigInt）</li><li>引用类型：Object</li></ul><h3 id="JS有哪些内置对象"><a href="#JS有哪些内置对象" class="headerlink" title="JS有哪些内置对象"></a>JS有哪些内置对象</h3><ul><li>Math对象：Math.abs(x);    //用来返回数的绝对值</li><li>Date对象：var date = new Date();// 通过new的方式创建一个日期对象</li><li>Array对象：var arr=new Array()</li><li>字符串对象：var str=new String()</li></ul><h3 id="JS的类型转换"><a href="#JS的类型转换" class="headerlink" title="JS的类型转换"></a>JS的类型转换</h3><p>变量的类型转换分为两种，主动进行的是显示类型转换，另一种为隐式类型转换</p><p><a href="https://juejin.im/post/6844903632974905358#heading-7" target="_blank" rel="noopener">详见</a></p><h3 id="underfined和null的区别"><a href="#underfined和null的区别" class="headerlink" title="underfined和null的区别"></a>underfined和null的区别</h3><p>null表示”没有对象”，即该处不应该有值</p><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span><span class="hljs-comment">// true</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)<span class="hljs-comment">// 0</span><span class="hljs-number">5</span> + <span class="hljs-literal">null</span><span class="hljs-comment">// 5</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)<span class="hljs-comment">// NaN</span><span class="hljs-number">5</span> + <span class="hljs-literal">undefined</span><span class="hljs-comment">// NaN</span></code></pre></div><p> <a href="https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">详见</a></p><h3 id="与-的区别"><a href="#与-的区别" class="headerlink" title="== 与 === 的区别"></a>== 与 === 的区别</h3><p><code>==</code> 两边值类型不同的时候，要先进行类型转换，再比较</p><p><code>===</code> 不做类型转换，类型不同的一定不等</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起构成<strong>闭包</strong>（<strong>closure</strong>）。闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。可以简单理解为“定义在一个函数内部的函数“ <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN</a></p><p>闭包指有权访问另一个函数作用域变量的函数。 —JavaScript高级程序设计</p><p>优点：</p><ol><li>逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑</li><li>方便调用上下文的局部变量</li><li>加强封装性，第2点的延伸，可以达到对变量的保护作用</li></ol><p>缺点：</p><p>闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><h3 id="JavaScript中apply、call和bind的区别"><a href="#JavaScript中apply、call和bind的区别" class="headerlink" title="JavaScript中apply、call和bind的区别"></a><a href="https://www.cnblogs.com/cosiray/p/4512969.html" target="_blank" rel="noopener">JavaScript中apply、call和bind的区别</a></h3><h3 id="防抖与节流，写一个防抖函数"><a href="#防抖与节流，写一个防抖函数" class="headerlink" title="防抖与节流，写一个防抖函数"></a>防抖与节流，写一个防抖函数</h3><h3 id="promise，实现一个promiseAll"><a href="#promise，实现一个promiseAll" class="headerlink" title="promise，实现一个promiseAll"></a>promise，实现一个promiseAll</h3><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="常用数据结构与使用场景"><a href="#常用数据结构与使用场景" class="headerlink" title="常用数据结构与使用场景"></a>常用数据结构与使用场景</h3><h3 id="排序算法有哪些，实现一个"><a href="#排序算法有哪些，实现一个" class="headerlink" title="排序算法有哪些，实现一个"></a>排序算法有哪些，实现一个</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="content类型"><a href="#content类型" class="headerlink" title="content类型"></a>content类型</h3><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="网页从输入网址到渲染完成经历了哪些过程"><a href="#网页从输入网址到渲染完成经历了哪些过程" class="headerlink" title="网页从输入网址到渲染完成经历了哪些过程"></a>网页从输入网址到渲染完成经历了哪些过程</h3><ol><li>输入网址；</li><li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</li><li>与web服务器建立TCP连接；</li><li>浏览器向web服务器发送http请求；</li><li>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</li><li>浏览器下载web服务器返回的数据及解析html源文件；</li><li>生成DOM树，解析css和js，渲染页面，直至显示完成；</li></ol><h3 id="ajax请求的过程"><a href="#ajax请求的过程" class="headerlink" title="ajax请求的过程"></a>ajax请求的过程</h3><ol><li>创建XMLHttpRequest对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>设置响应HTTP请求状态变化的函数，发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用JavaScript和DOM实现局部刷新</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/60832562" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60832562</a></p><p><a href="https://developer.mozilla.org/" target="_blank" rel="noopener">https://developer.mozilla.org/</a></p><p><a href="https://juejin.im/post/6844903950500495373" target="_blank" rel="noopener">https://juejin.im/post/6844903950500495373</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts动态更新数据与dataZoom的问题</title>
    <link href="/2020/08/03/ECharts%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%8EdataZoom%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/03/ECharts%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%8EdataZoom%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在前端定时获取数据并动态展示在图表中，可以鼠标拖动查看不同时间段的数据。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>实时更新数据方法就是每次调用接口获取数据成功后，将数据push到存放数据的数组中，然后调用ECharts的setOption方法重新绘制即可，鼠标拖动查看使用<a href="https://echarts.apache.org/zh/option.html#dataZoom" target="_blank" rel="noopener">dataZoom</a>即可。</p><p><img src="/blogImg/image-20200805114655583.png" srcset="/img/loading.gif" alt="image-20200805114655583"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="dataZoom重置"><a href="#dataZoom重置" class="headerlink" title="dataZoom重置"></a>dataZoom重置</h3><p>在用户使用dataZoom组件查看数据时，数据进行了更新并调用了setOption重绘，这时dataZoom被重置为初始状态。我们希望在dataZoom选择的位置不会因为数据更新而改变，产生跳动的情况。</p><p>dataZoom中使用start和end标记数据窗口的显示范围，在用户操作后，记录下当前的start和end值，在下次数据刷新时使用，就能使窗口位置保持不变。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">this</span>.myChart.on(<span class="hljs-string">'dataZoom'</span>, (event) =&gt; &#123;  <span class="hljs-keyword">this</span>.dataZoom.end = event.end  <span class="hljs-keyword">this</span>.dataZoom.start = event.start&#125;)</code></pre></div><h3 id="动态刷新后x，y轴数据不对应"><a href="#动态刷新后x，y轴数据不对应" class="headerlink" title="动态刷新后x，y轴数据不对应"></a>动态刷新后x，y轴数据不对应</h3><p>平滑曲线下</p><p><img src="/blogImg/image-20200803102658000.png" srcset="/img/loading.gif" alt="image-20200803102658000"></p><p>折线图</p><p><img src="/blogImg/image-20200803102849410.png" srcset="/img/loading.gif" alt="image-20200803102849410"></p><p>解决方法：</p><ol><li><p>在setOption中设置<code>animation: false</code> 关闭动画</p></li><li><p>在dataZoom中设置<code>filterMode: &#39;empty&#39;</code> </p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ECharts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECharts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析Corn表达式</title>
    <link href="/2020/07/30/%E8%A7%A3%E6%9E%90Corn%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/07/30/%E8%A7%A3%E6%9E%90Corn%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Corn表达式"><a href="#Corn表达式" class="headerlink" title="Corn表达式"></a>Corn表达式</h2><p>Cron表达式是以字符串的形式表示时间或时间间隔，分为6~7个域，每个域代表一个含义，从左到右（用空格隔开）分别为：秒 分 小时 月份中的日期 月份 星期中的日期 年份</p><p>范例：</p><div class="hljs"><pre><code class="hljs angelscript">*/<span class="hljs-number">5</span> * * * * ?    <span class="hljs-comment">// 每隔5秒</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span> * * ?   <span class="hljs-comment">// 每天上午10点，下午2点，4点</span><span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * <span class="hljs-number">6</span>L    <span class="hljs-comment">// 每月的最后一个星期五上午10:15触发</span></code></pre></div><h2 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h2><p>项目要求将Cron表达式在前端翻译成中文展示，效果如下：</p><p><img src="/blogImg/image-20200731104901395.png" srcset="/img/loading.gif" alt="image-20200731104901395"></p><p>使用cRonstrue这个js库进行解析:<a href="https://github.com/bradymholt/cRonstrue" target="_blank" rel="noopener">github链接</a>,<a href="https://www.npmjs.com/package/cronstrue" target="_blank" rel="noopener">npm</a></p><p>安装modules</p><div class="hljs"><pre><code class="hljs bash">npm install cronstrue</code></pre></div><p>在页面中导入：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> cronstrue <span class="hljs-keyword">from</span> <span class="hljs-string">'cronstrue'</span>;</code></pre></div><p>默认为英文，需要翻译成其他语言的话，应该使用cRonstrue提供的i18n支持</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> cronstrue <span class="hljs-keyword">from</span> <span class="hljs-string">'cronstrue/i18n'</span><span class="hljs-comment">// text为需要解析的Cron表达式字符串，zh_CN表示翻译为简体中文</span>cronstrue.toString(text, &#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">'zh_CN'</span> &#125;)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="/2020/07/27/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/27/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>要求算法具有线性时间复杂度，且不使用额外空间实现。</p><p><a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/25/" target="_blank" rel="noopener">链接</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>使用异或运算⊕，异或运算的性质：</p><ol><li>任何数和0做异或运算，结果仍然是原来的数，即<em>a</em>⊕0=<em>a</em>。</li><li>任何数与其自身做异或运算，结果是0，即<em>a</em>⊕<em>a</em>=<em>a</em>⊕<em>a</em>=0。</li><li>异或运算满足交换律和结合律，即<em>a</em>⊕<em>b</em>⊕<em>a</em>=<em>b</em>⊕<em>a</em>⊕<em>a</em>=<em>b</em>⊕(<em>a</em>⊕<em>a</em>)=<em>b</em>⊕0=<em>b</em>。</li></ol><p>Java写法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> single = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            single ^= num;        &#125;        <span class="hljs-keyword">return</span> single;    &#125;&#125;</code></pre></div><p>JavaScript写法：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> singleNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> single = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;        single ^= num    &#125;    <span class="hljs-keyword">return</span> single;&#125;;</code></pre></div><p>时间复杂度为O(n)，空间复杂度为O(1)</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="空间复杂度与时间复杂度不要求时"><a href="#空间复杂度与时间复杂度不要求时" class="headerlink" title="空间复杂度与时间复杂度不要求时"></a>空间复杂度与时间复杂度不要求时</h3><h4 id="使用集合存储数字"><a href="#使用集合存储数字" class="headerlink" title="使用集合存储数字"></a>使用集合存储数字</h4><p>遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> singleNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> numberSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;        <span class="hljs-keyword">if</span>(numberSet.has(num)) &#123;            numberSet.delete(num)        &#125; <span class="hljs-keyword">else</span> &#123;            numberSet.add(num)        &#125;    &#125;    <span class="hljs-keyword">let</span> myArray = <span class="hljs-built_in">Array</span>.from(numberSet);    <span class="hljs-keyword">return</span> myArray[<span class="hljs-number">0</span>]&#125;;</code></pre></div><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。当数字出现次数不一定为2次时也可使用。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>实在是想不到使用异或运算解决这个问题，复习一下其他的位运算符。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">MDN</a></p><table><thead><tr><th>含义</th><th>运算符</th><th align="left">特点</th></tr></thead><tbody><tr><td>左移</td><td>&lt;&lt;</td><td align="left">该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。</td></tr><tr><td>有符号右移</td><td>&gt;&gt;</td><td align="left">该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。</td></tr><tr><td>无符号右移</td><td>&gt;&gt;&gt;</td><td align="left">该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</td></tr><tr><td>按位或</td><td>|</td><td align="left">有1为1，全0为0</td></tr><tr><td>按位与</td><td>&amp;</td><td align="left">全1为1，有0为0</td></tr><tr><td>按位非</td><td>~</td><td align="left">取反</td></tr><tr><td>按位异或</td><td>^</td><td align="left">相同为0，不同为1</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重排与重绘</title>
    <link href="/2020/07/23/%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
    <url>/2020/07/23/%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>DOM树（DOM tree）：浏览器解析HTML文本创建的树结构</p><p>CSSOM（CSS Object Model）：将样式表中的规则映射到页面对应的元素上</p><p>渲染树（render tree）：CSSOM和DOM树合并成渲染树，只包含渲染网页所需的节点</p><p>重排（relayout）：在Firefox中被称为reflow（回流），部分或整个渲染树需要重新分析并且节点尺寸需要重新计算</p><p>重绘（repaint/redraw）：节点的几何属性或样式发生改变，屏幕进行内容的更新，称为重绘</p><h2 id="触发重排与重绘的情况"><a href="#触发重排与重绘的情况" class="headerlink" title="触发重排与重绘的情况"></a>触发重排与重绘的情况</h2><h3 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h3><ul><li><p>页面第一次渲染 在页面发生首次渲染的时候，所有组件都要进行首次布局，这是开销最大的一次重排</p></li><li><p>浏览器窗口尺寸改变</p></li><li><p>元素位置和尺寸发生改变的时候</p></li><li><p>新增和删除可见元素</p></li><li><p>内容发生改变（文字数量或图片大小等等） </p></li><li><p>元素字体大小变化</p></li><li><p>激活CSS伪类</p></li><li><p>设置style属性</p></li><li><p>查询某些属性或调用某些方法，比如说：</p><p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p></li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><ul><li><code>vidibility</code>、<code>outline</code>、背景色等属性的改变</li></ul><p>重绘不一定导致重排，重排一定导致重绘</p><h2 id="避免或减少重排带来的开销"><a href="#避免或减少重排带来的开销" class="headerlink" title="避免或减少重排带来的开销"></a>避免或减少重排带来的开销</h2><h3 id="分离读写操作"><a href="#分离读写操作" class="headerlink" title="分离读写操作"></a>分离读写操作</h3><div class="hljs"><pre><code class="hljs javascript">div.style.top = <span class="hljs-string">"10px"</span>;div.style.bottom = <span class="hljs-string">"10px"</span>;div.style.right = <span class="hljs-string">"10px"</span>;div.style.left = <span class="hljs-string">"10px"</span>;<span class="hljs-built_in">console</span>.log(div.offsetWidth);<span class="hljs-built_in">console</span>.log(div.offseHeight);<span class="hljs-built_in">console</span>.log(div.offsetRight);<span class="hljs-built_in">console</span>.log(div.offsetLeft);</code></pre></div><p>原来的操作会导致四次重排和四次重绘，变换顺序之后只会触发一次重排 在第一个<code>console</code>的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。因为渲染队列本来就是空的，所以剩下的<code>console</code>并没有触发重排，仅仅拿值而已。</p><h3 id="样式集中改变"><a href="#样式集中改变" class="headerlink" title="样式集中改变"></a>样式集中改变</h3><p>通过<code>class</code>和<code>cssText</code>进行集中改变样式</p><h3 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// bad 强制刷新 触发两次重排</span>div.style.left = div.offsetLeft + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;div.style.top = div.offsetTop + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;<span class="hljs-comment">// good 缓存布局信息 相当于读写分离</span><span class="hljs-keyword">var</span> curLeft = div.offsetLeft;<span class="hljs-keyword">var</span> curTop = div.offsetTop;div.style.left = curLeft + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;div.style.top = curTop + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;</code></pre></div><h3 id="DOM离线"><a href="#DOM离线" class="headerlink" title="DOM离线"></a>DOM离线</h3><ul><li><p>一旦我们给元素设置<code>display:none</code>时，元素不会存在于渲染树中，相当于将其从页面“拿掉”，我们之后的操作将不会触发重排和重绘，这叫做DOM的离线化。</p></li><li><p>通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">DocumentFragment</a>创建一个<code>dom</code>碎片,在它上面批量操作<code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#list'</span>);<span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">'Apple'</span>, <span class="hljs-string">'Orange'</span>, <span class="hljs-string">'Banana'</span>, <span class="hljs-string">'Melon'</span>];<span class="hljs-keyword">const</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();fruits.forEach(<span class="hljs-function"><span class="hljs-params">fruit</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);  li.innerHTML = fruit;  fragment.appendChild(li);&#125;);list.appendChild(fragment);</code></pre></div></li></ul><h3 id="将position属性设置为absolute或fixed"><a href="#将position属性设置为absolute或fixed" class="headerlink" title="将position属性设置为absolute或fixed"></a>将position属性设置为absolute或fixed</h3><p><code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素，重排开销比较小，不用考虑它对其他元素的影响</p><h3 id="优化动画"><a href="#优化动画" class="headerlink" title="优化动画"></a>优化动画</h3><ul><li>把动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上，这样对其他元素影响较小</li><li>启用GPU加速</li></ul><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://juejin.im/entry/582f16fca22b9d006b7afd89" target="_blank" rel="noopener">https://juejin.im/entry/582f16fca22b9d006b7afd89</a></p><p><a href="https://imweb.io/topic/5c2206a7611a25cc7bf1d848" target="_blank" rel="noopener">https://imweb.io/topic/5c2206a7611a25cc7bf1d848</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leaflet自定义popup弹框样式</title>
    <link href="/2020/07/21/leaflet%E8%87%AA%E5%AE%9A%E4%B9%89popup%E5%BC%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"/>
    <url>/2020/07/21/leaflet%E8%87%AA%E5%AE%9A%E4%B9%89popup%E5%BC%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>leaflet弹窗popup使用实例：</p><div class="hljs"><pre><code class="hljs javascript">L.marker([<span class="hljs-number">51.5</span>, <span class="hljs-number">-0.09</span>]).addTo(map)    .bindPopup(<span class="hljs-string">'A pretty CSS3 popup.&lt;br&gt; Easily customizable.'</span>)    .openPopup();</code></pre></div><p><img src="/blogImg/image-20200721160638664.png" srcset="/img/loading.gif" alt="image-20200721160638664"></p><p>popup的内容是将html代码以字符串的形式放在bindPopup中，如果弹窗中内容比较复杂，则编写与维护都比较困难，所以考虑将弹窗的内容独立出来。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>先创建一个新文件存放PopupContent的内容，这里是PopupContent.vue</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;!--这里写需要的弹窗内容 --&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;PopupContent&#39;,  props: &#123;&#x2F;&#x2F; 接收传来的数据    popupData: &#123;      type: Object,      default: () &#x3D;&gt; &#123;&#125;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p>在需要用到弹窗的页面引入这个组件，并定义一个popup，setContent中内容为一个有id的div，需要给定一个宽度，也可在之后的操作中给定一个值。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> popupContent <span class="hljs-keyword">from</span> <span class="hljs-string">'./PopupContent'</span></code></pre></div><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> popup = L.popup().setLatLng(e.latlng)            .setContent(<span class="hljs-string">'&lt;div id="mapDialog-container" style="width: 260px"&gt;&lt;/div&gt;'</span>)            .openOn(<span class="hljs-keyword">this</span>.map)</code></pre></div><p>然后调用下面这个方法将弹窗内容组件挂载到id为mapDialog-container的元素上</p><div class="hljs"><pre><code class="hljs javascript">getDialog (data) &#123;    <span class="hljs-comment">// 创建构造器</span>    <span class="hljs-keyword">let</span> Profile = Vue.extend(popupContent)    <span class="hljs-comment">// 创建 Profile 实例，并挂载到一个元素上。</span>    <span class="hljs-keyword">new</span> Profile(&#123; <span class="hljs-attr">propsData</span>: &#123; <span class="hljs-attr">popupData</span>: data &#125; &#125;).$mount(<span class="hljs-string">'#mapDialog-container'</span>)&#125;</code></pre></div><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="/blogImg/image-20200721165453487.png" srcset="/img/loading.gif" alt="image-20200721165453487"></p><p><img src="/blogImg/image-20200721165745138.png" srcset="/img/loading.gif" alt="image-20200721165745138"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>leaflet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leaflet</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Canvas教程学习</title>
    <link href="/2020/07/19/Canvas%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/07/19/Canvas%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Canvas介绍"><a href="#Canvas介绍" class="headerlink" title="Canvas介绍"></a>Canvas介绍</h2><p><code>&lt;canvas&gt;</code>是一个可以使用脚本(通常为JavaScript)来绘制图形的HTML元素。,它可以用于绘制图表、制作图片构图或者制作简单的(以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/A_basic_ray-caster" target="_blank" rel="noopener">不那么简单的</a>)动画. </p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener">教程链接</a></p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="Canvas元素"><a href="#Canvas元素" class="headerlink" title="Canvas元素"></a>Canvas元素</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tutorial"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span></code></pre></div><p>Canvas 的默认大小为300像素×150像素，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。</p><h3 id="替换内容"><a href="#替换内容" class="headerlink" title="替换内容"></a>替换内容</h3><p>在<code>&lt;canvas&gt;</code>标签中提供了替换内容。不支持<code>&lt;canvas&gt;</code>的浏览器将会忽略容器并在其中渲染后备内容。而支持<code>&lt;canvas&gt;</code>的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"stockGraph"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150"</span>&gt;</span>  current stock price: $3.15 +0.15<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clock"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"images/clock.png"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span></code></pre></div><h3 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h3><p><code>&lt;canvas&gt;</code>元素创造了一个固定大小的画布，它公开了一个或多个<strong>渲染上下文</strong>，其可以用来绘制和处理要展示的内容。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'tutorial'</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);</code></pre></div><p>第一行通过使用 <code>document.getElementById()</code>方法来为<code>&lt;canvas&gt;</code>元素得到DOM对象。一旦有了元素对象，就可以通过使用它的<code>getContext()</code>方法来访问绘画上下文。</p><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h3><p>画布栅格(canvas grid)，起点为左上角（0，0）</p><p><img src="/blogImg/Canvas_default_grid.png" srcset="/img/loading.gif" alt="img"></p><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p><code>&lt;canvas&gt;</code>只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。</p><p>绘制一个填充的矩形:</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect" target="_blank" rel="noopener"><code>fillRect(x, y, width, height)</code></a></p><p>绘制一个矩形的边框:</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeRect" target="_blank" rel="noopener"><code>strokeRect(x, y, width, height)</code></a></p><p>清除指定矩形区域，让清除部分完全透明:</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clearRect" target="_blank" rel="noopener"><code>clearRect(x, y, width, height)</code></a></p><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">beginPath</span><span class="hljs-params">()</span></span></code></pre></div><p>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">closePath</span><span class="hljs-params">()</span></span></code></pre></div><p>闭合路径之后图形绘制命令又重新指向到上下文中。</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">stroke</span><span class="hljs-params">()</span></span></code></pre></div><p>通过线条来绘制图形轮廓。</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fill</span><span class="hljs-params">()</span></span></code></pre></div><p>通过填充路径的内容区域生成实心的图形。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 绘制三角形</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);  <span class="hljs-keyword">if</span> (canvas.getContext) &#123;    <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);    ctx.beginPath();    ctx.moveTo(<span class="hljs-number">75</span>, <span class="hljs-number">50</span>);    ctx.lineTo(<span class="hljs-number">100</span>, <span class="hljs-number">75</span>);    ctx.lineTo(<span class="hljs-number">100</span>, <span class="hljs-number">25</span>);    ctx.fill();  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs reasonml">move<span class="hljs-constructor">To(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span></code></pre></div><p>将笔触移动到指定的坐标x以及y上。</p><p>当canvas初始化或者<code>beginPath()</code>调用后，你通常会使用<code>moveTo()</code>函数设置起点。我们也能够使用<code>moveTo()</code>绘制一些不连续的路径。看一下下面的笑脸例子。我将用到<code>moveTo()</code>方法（红线处）的地方标记了。</p><h3 id="线"><a href="#线" class="headerlink" title="线"></a>线</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineTo" target="_blank" rel="noopener"><code>lineTo(x, y)</code></a></p><p>绘制一条从当前位置到指定x以及y位置的直线。</p><h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/arc" target="_blank" rel="noopener"><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code></a></p><p>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/arcTo" target="_blank" rel="noopener"><code>arcTo(x1, y1, x2, y2, radius)</code></a></p><p>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-built_in">rect</span>(x, y, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>)</code></pre></div><p>绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。</p><h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 封装的一个用于绘制圆角矩形的函数.</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">roundedRect</span>(<span class="hljs-params">ctx, x, y, width, height, radius</span>)</span>&#123;  ctx.beginPath();  ctx.moveTo(x, y + radius);  ctx.lineTo(x, y + height - radius);  ctx.quadraticCurveTo(x, y + height, x + radius, y + height);  ctx.lineTo(x + width - radius, y + height);  ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);  ctx.lineTo(x + width, y + radius);  ctx.quadraticCurveTo(x + width, y, x + width - radius, y);  ctx.lineTo(x + radius, y);  ctx.quadraticCurveTo(x, y, x, y + radius);  ctx.stroke();&#125;</code></pre></div><h2 id="Path2D对象"><a href="#Path2D对象" class="headerlink" title="Path2D对象"></a>Path2D对象</h2><p>用来缓存或记录绘画命令，这样你将能快速地回顾路径。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);  <span class="hljs-keyword">if</span> (canvas.getContext)&#123;    <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);    <span class="hljs-keyword">var</span> rectangle = <span class="hljs-keyword">new</span> Path2D();    rectangle.rect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);    <span class="hljs-keyword">var</span> circle = <span class="hljs-keyword">new</span> Path2D();    circle.moveTo(<span class="hljs-number">125</span>, <span class="hljs-number">35</span>);    circle.arc(<span class="hljs-number">100</span>, <span class="hljs-number">35</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI);    ctx.stroke(rectangle);    ctx.fill(circle);  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Canvas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在element-ui下拉选项前添加checkbox</title>
    <link href="/2020/07/17/%E5%9C%A8element-ui%E4%B8%8B%E6%8B%89%E9%80%89%E9%A1%B9%E5%89%8D%E6%B7%BB%E5%8A%A0checkbox/"/>
    <url>/2020/07/17/%E5%9C%A8element-ui%E4%B8%8B%E6%8B%89%E9%80%89%E9%A1%B9%E5%89%8D%E6%B7%BB%E5%8A%A0checkbox/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在select下拉菜单的选项前添加多选框checkbox，并且有一个全选选项</p><p>效果如下：</p><p><img src="/blogImg/20200717.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>在el-option选项中嵌入el-checkbox组件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-select</span></span><span class="hljs-tag">          <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selectValueArray"</span></span><span class="hljs-tag">          <span class="hljs-attr">multiple</span></span><span class="hljs-tag">          <span class="hljs-attr">collapse-tags</span></span><span class="hljs-tag">          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请选择分析专题"</span></span><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">"select-with-checkbox"</span></span><span class="hljs-tag">        &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span></span><span class="hljs-tag">            <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in analysisSubject"</span></span><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">"my-select"</span></span><span class="hljs-tag">            <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.value"</span></span><span class="hljs-tag">            <span class="hljs-attr">:value</span>=<span class="hljs-string">"item.value"</span></span><span class="hljs-tag">            <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"item.disabled"</span></span><span class="hljs-tag">          &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-checkbox</span></span><span class="hljs-tag">              <span class="hljs-attr">class</span>=<span class="hljs-string">"inner-checkbox"</span></span><span class="hljs-tag">              <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"item.disabled"</span></span><span class="hljs-tag">              <span class="hljs-attr">v-model</span>=<span class="hljs-string">"item.checked"</span></span><span class="hljs-tag">              @<span class="hljs-attr">change</span>=<span class="hljs-string">"onSelectChange"</span></span><span class="hljs-tag">              &gt;</span>&#123;&#123; item.label &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el-checkbox</span></span><span class="hljs-tag">            &gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span></code></pre></div><p>样式修改</p><div class="hljs"><pre><code class="hljs scss"><span class="hljs-comment">// 屏蔽原有的选中图标</span><span class="hljs-selector-class">.my-select</span><span class="hljs-selector-pseudo">::after</span> &#123;  <span class="hljs-attribute">display</span>: none;&#125;<span class="hljs-comment">// 将checkbox的大小覆盖整个选项</span><span class="hljs-selector-class">.inner-checkbox</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;&#125;<span class="hljs-comment">// 原有选项padding置0</span><span class="hljs-selector-class">.el-select-dropdown__item</span> &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 偷懒屏蔽了input中选项的关闭按钮</span><span class="hljs-selector-class">.select-with-checkbox</span> &#123;  ::v-deep .el-tag.el-tag--info .el-tag__close &#123;    display: none;  &#125;&#125;</code></pre></div><p>TypeScript代码如下：</p><div class="hljs"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> ComplianceAudit <span class="hljs-keyword">extends</span> Vue &#123;      <span class="hljs-keyword">private</span> selectValueArray: <span class="hljs-built_in">any</span>[] = []; <span class="hljs-comment">// 已选信息数组</span>  <span class="hljs-keyword">private</span> oldSelectValueArray: <span class="hljs-built_in">any</span>[] = []; <span class="hljs-comment">// 记录上次选择的信息数组</span>    <span class="hljs-comment">//analysisSubject数组的格式如下：</span>    <span class="hljs-keyword">private</span> analysisSubject: <span class="hljs-built_in">any</span>[] = [        <span class="hljs-comment">// 选项信息数组</span>        &#123;          value: <span class="hljs-string">"城镇开发边界"</span>,          label: <span class="hljs-string">"城镇开发边界"</span>,          checked: <span class="hljs-literal">false</span>        &#125;,        &#123;          value: <span class="hljs-string">"1111"</span>,          label: <span class="hljs-string">"2222"</span>,          checked: <span class="hljs-literal">false</span>        &#125;,        &#123; value: <span class="hljs-string">"ALL_SELECT"</span>, label: <span class="hljs-string">"全选"</span>, checked: <span class="hljs-literal">false</span> &#125;    ]    <span class="hljs-comment">/**</span><span class="hljs-comment">     * checkbox修改事件onSelectChange：</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> onSelectChange(val: <span class="hljs-built_in">any</span>[]) &#123;        <span class="hljs-keyword">this</span>.selectValueArray = [];<span class="hljs-comment">// 已选信息数组置空</span>        <span class="hljs-comment">// allValues为所有选项值的数组</span>        <span class="hljs-keyword">const</span> allValues = <span class="hljs-keyword">this</span>.analysisSubject.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (item.checked) &#123;            <span class="hljs-comment">// 将checked为true的值放入已选信息数组</span>            <span class="hljs-keyword">this</span>.selectValueArray.push(item.value);          &#125;          <span class="hljs-keyword">return</span> item.value;        &#125;);        <span class="hljs-comment">// 上一次选择的值，进行对比</span>        <span class="hljs-keyword">const</span> oldVal =          <span class="hljs-keyword">this</span>.oldSelectValueArray.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">this</span>.oldSelectValueArray : [];        <span class="hljs-comment">// 选择全部，这次含有全选项且上次没有</span>        <span class="hljs-keyword">if</span> (          <span class="hljs-keyword">this</span>.selectValueArray.includes(<span class="hljs-string">"ALL_SELECT"</span>) &amp;&amp;          !oldVal.includes(<span class="hljs-string">"ALL_SELECT"</span>)        ) &#123;          <span class="hljs-keyword">this</span>.selectValueArray = allValues;          <span class="hljs-keyword">this</span>.changeCheckboxStatus(<span class="hljs-keyword">this</span>.analysisSubject, <span class="hljs-string">"ALL"</span>, <span class="hljs-literal">true</span>);        &#125;        <span class="hljs-comment">// 取消全部选中，上次存在全选项，当前没有，则取消全选</span>        <span class="hljs-keyword">if</span> (          oldVal.includes(<span class="hljs-string">"ALL_SELECT"</span>) &amp;&amp;          !<span class="hljs-keyword">this</span>.selectValueArray.includes(<span class="hljs-string">"ALL_SELECT"</span>)        ) &#123;          <span class="hljs-keyword">this</span>.selectValueArray = [];          <span class="hljs-keyword">this</span>.changeCheckboxStatus(<span class="hljs-keyword">this</span>.analysisSubject, <span class="hljs-string">"ALL"</span>, <span class="hljs-literal">false</span>);        &#125;        <span class="hljs-comment">// 点击非全部选中，需要排除全部选中 以及 当前点击的选项</span>        <span class="hljs-comment">// 新老数据都有全部选中</span>        <span class="hljs-keyword">if</span> (          oldVal.includes(<span class="hljs-string">"ALL_SELECT"</span>) &amp;&amp;          <span class="hljs-keyword">this</span>.selectValueArray.includes(<span class="hljs-string">"ALL_SELECT"</span>)        ) &#123;          <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.selectValueArray.indexOf(<span class="hljs-string">"ALL_SELECT"</span>);          <span class="hljs-keyword">this</span>.selectValueArray.splice(index, <span class="hljs-number">1</span>); <span class="hljs-comment">// 排除全选选项</span>          <span class="hljs-keyword">this</span>.changeCheckboxStatus(<span class="hljs-keyword">this</span>.analysisSubject, <span class="hljs-string">"ALL_SELECT"</span>, <span class="hljs-literal">false</span>);        &#125;        <span class="hljs-comment">// 全选未选，但是其他选项都全部选上了，则全选选上</span>        <span class="hljs-keyword">if</span> (          !oldVal.includes(<span class="hljs-string">"ALL_SELECT"</span>) &amp;&amp;          !<span class="hljs-keyword">this</span>.selectValueArray.includes(<span class="hljs-string">"ALL_SELECT"</span>)        ) &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.selectValueArray.length === allValues.length - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">this</span>.selectValueArray.push(<span class="hljs-string">"ALL_SELECT"</span>);            <span class="hljs-keyword">this</span>.changeCheckboxStatus(<span class="hljs-keyword">this</span>.analysisSubject, <span class="hljs-string">"ALL_SELECT"</span>, <span class="hljs-literal">true</span>);          &#125;        &#125;        <span class="hljs-comment">// 储存当前选择的最后结果 作为下次的老数据</span>        <span class="hljs-keyword">this</span>.oldSelectValueArray = <span class="hljs-keyword">this</span>.selectValueArray;      &#125;          <span class="hljs-comment">/**</span><span class="hljs-comment">       * 修改复选框选中状态</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">private</span> changeCheckboxStatus(list: <span class="hljs-built_in">any</span>, value: <span class="hljs-built_in">string</span>, status: <span class="hljs-built_in">boolean</span>) &#123;        <span class="hljs-comment">// 全部修改</span>        <span class="hljs-keyword">if</span> (value == <span class="hljs-string">"ALL"</span>) &#123;          list.forEach(<span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;            item.checked = status;          &#125;);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 指定某个值修改</span>          list.forEach(<span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (item.value == value) &#123;              item.checked = status;            &#125;          &#125;);        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios取消上次请求</title>
    <link href="/2020/07/15/Axios%E5%8F%96%E6%B6%88%E4%B8%8A%E6%AC%A1%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/07/15/Axios%E5%8F%96%E6%B6%88%E4%B8%8A%E6%AC%A1%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用户重复点击发送请求，由于请求速度较慢，导致多次请求的数据在同一个弹窗中显示，数据不匹配。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p> <a href="https://github.com/axios/axios#axios-api" target="_blank" rel="noopener">Axios文档</a>中提供了取消请求的方法，cancel token API</p></blockquote><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<span class="hljs-keyword">const</span> source = CancelToken.source();axios.get(<span class="hljs-string">'/user/12345'</span>, &#123;  cancelToken: source.token&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thrown</span>) </span>&#123;  <span class="hljs-keyword">if</span> (axios.isCancel(thrown)) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Request canceled'</span>, thrown.message);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// handle error</span>  &#125;&#125;);axios.post(<span class="hljs-string">'/user/12345'</span>, &#123;  name: <span class="hljs-string">'new name'</span>&#125;, &#123;  cancelToken: source.token&#125;)<span class="hljs-comment">// cancel the request (the message parameter is optional)</span>source.cancel(<span class="hljs-string">'Operation canceled by the user.'</span>);</code></pre></div><p>You can also create a cancel token by passing an executor function to the <code>CancelToken</code> constructor:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<span class="hljs-keyword">let</span> cancel;axios.get(<span class="hljs-string">'/user/12345'</span>, &#123;  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>&#123;    <span class="hljs-comment">// An executor function receives a cancel function as a parameter</span>    cancel = c;  &#125;)&#125;);<span class="hljs-comment">// cancel the request</span>cancel();</code></pre></div><blockquote><p>Note: you can cancel several requests with the same cancel token.</p></blockquote><h2 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h2><div class="hljs"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<span class="hljs-keyword">import</span> &#123; Vue, Component, Watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-property-decorator"</span>;<span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<span class="hljs-meta">@Component</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> LayerControlMixins <span class="hljs-keyword">extends</span> Vue &#123;    <span class="hljs-keyword">private</span> cancel: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 点击事件函数</span>    <span class="hljs-keyword">private</span> bindClickQuery() &#123;<span class="hljs-comment">// 判断并取消上次请求</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cancel) &#123;          <span class="hljs-keyword">this</span>.cancel();        &#125;        <span class="hljs-keyword">let</span> that = <span class="hljs-keyword">this</span>        <span class="hljs-comment">// 触发请求</span>        axios           .post(url, <span class="hljs-built_in">JSON</span>.stringify(params), &#123;               cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>&#123;                 that.cancel = c;               &#125;)           &#125;)           .then(<span class="hljs-function">(<span class="hljs-params">res: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;               <span class="hljs-built_in">console</span>.log(res)               <span class="hljs-comment">// ...</span>           &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Axios</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot使用@autowire注入为null的问题</title>
    <link href="/2020/01/20/SpringBoot%E4%BD%BF%E7%94%A8-autowire%E6%B3%A8%E5%85%A5%E4%B8%BAnull%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/01/20/SpringBoot%E4%BD%BF%E7%94%A8-autowire%E6%B3%A8%E5%85%A5%E4%B8%BAnull%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot使用-autowire注入为null的问题"><a href="#SpringBoot使用-autowire注入为null的问题" class="headerlink" title="SpringBoot使用@autowire注入为null的问题"></a>SpringBoot使用@autowire注入为null的问题</h1><p>当类不是controller，使用Autowired注入的方法显示为null。这个出现原因其实就是此类是在bean加载之前被调用，或者springboot在加载时没有识别到此类，所以注入为空，要想使此类被识别到，那么就要在启动时被spring识别到，需要将其变为bean对象并被识别到。</p><a id="more"></a><p>不使用Autowired注解，改为如下方式</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> IDeviceService deviceService = (IDeviceService) SpringContextUtils.getBean(IDeviceService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><p>将需要调用Spring的Service层的类通过@Component注解为组件加载；通过@Autowired获取Service层的Bean对象；为类声明一个静态变量，方便下一步存储bean对象；通过注解@PostConstruct ，在初始化的时候初始化静态对象和它的静态成员变量，拿到bean对象，静态存储下来，防止被释放。</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThresholdAlarm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SampleParamJob</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IDeviceService deviceService;    <span class="hljs-comment">// 声明一个静态变量，用于存储bean对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThresholdAlarm thresholdAlarm ;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"@PostConstruct方法被调用"</span>);        thresholdAlarm = <span class="hljs-keyword">this</span>;        thresholdAlarm.deviceService = <span class="hljs-keyword">this</span>.deviceService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Device&gt; <span class="hljs-title">getDeviceListByProductId</span><span class="hljs-params">(String productId)</span></span>&#123;        LambdaQueryWrapper&lt;Device&gt; query = <span class="hljs-keyword">new</span> LambdaQueryWrapper&lt;Device&gt;()                .in(Device::getProductId,productId)                .in(Device::getDeviceState,<span class="hljs-string">"1"</span>)                .orderByDesc(Device::getCreateTime);        List&lt;Device&gt; deviceList = thresholdAlarm.deviceService.list(query);        <span class="hljs-keyword">return</span> deviceList;    &#125;&#125;</code></pre><p><a href="https://blog.csdn.net/georgeshaw1/article/details/74943089" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础2</title>
    <link href="/2019/12/23/SQL%E5%9F%BA%E7%A1%802/"/>
    <url>/2019/12/23/SQL%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>用于代替字符串中的其他字符。</p><ul><li><code>%</code> ：代替0个或多个字符</li><li><code>_</code> ：代替一个字符</li><li><code>[charlist]</code> ：字符列中的任何单一字符</li><li><code>[^charlist]</code> 或 <code>[!charlist]</code> ：不在字符列中的任何单一字符</li></ul><p>搜索不以A或B或N开头的人：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'[!ABN]%'</span>;</code></pre></div><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>用于在where语句中搜索列的指定模式。</p><ul><li><p>搜索name为A开头的所有学生</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'A%'</span>;</code></pre></div></li><li><p>选取 name 不包含模式 “pp” 的所有学生：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%pp%'</span>;</code></pre></div></li></ul><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p>用于在where字句中规定多个值。</p><p>选取name为apple或banana的值：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>);</code></pre></div><h3 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h3><p>用于选取介于两个值之间的数据范围内的值。</p><ul><li><p>选取age在6到18的值：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">6</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">18</span>;</code></pre></div></li><li><p>选取日期不在1997-01-20和1997-10-05范围的值</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> birthday <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'1997-01-20'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'1997-10-05'</span>;</code></pre></div></li></ul><p>注意：不同数据库中的边界处理可能不相同。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>用于为表名称或列名称指定别名。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">AS</span> n, age <span class="hljs-keyword">AS</span> a<span class="hljs-keyword">FROM</span> student;</code></pre></div><ul><li><p>将多个列组合在一起输出</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>, <span class="hljs-keyword">CONCAT</span>(age, <span class="hljs-string">','</span>, sex, <span class="hljs-string">','</span>, country) <span class="hljs-keyword">AS</span> stu_info<span class="hljs-keyword">FROM</span> student;</code></pre></div></li><li><p>超过一个表的查询</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.name, s.age, t.name, t.assess<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, teacher <span class="hljs-keyword">AS</span> t<span class="hljs-keyword">WHERE</span> s.teacher = t.name <span class="hljs-keyword">and</span> s.country = <span class="hljs-string">'CHINA'</span>;</code></pre></div></li></ul><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><p>基于表之间的共同字段，把两个或多个表结合。</p><ul><li>INNER JOIN: 表中至少有一个匹配，则返回行</li><li>LEFT JOIN: 即使右表中没有匹配，也从左表中返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 只要其中一个表存在匹配，则返回行</li></ul><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>用于合并两个或多个SELECT语句的结果集，列的数量，数据类型，顺序必须相同。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> teacher<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;</code></pre></div><p>允许重复值使用UNION ALL。</p><h3 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h3><p>从一个表中复制数据插入到一个新表中。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">INTO</span> studentBackUp<span class="hljs-keyword">FROM</span> student;</code></pre></div><p>MySQL不支持</p><h3 id="INSERT-INTO-SELECT"><a href="#INSERT-INTO-SELECT" class="headerlink" title="INSERT INTO SELECT"></a>INSERT INTO SELECT</h3><p>从一个表中复制数据插入到一个已存在的表中。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> studentBackUp<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student;</code></pre></div><h3 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a>CREATE DATABASE</h3><p>用于创建数据库。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> mydatabase;</code></pre></div><h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><p>用于创建表。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<span class="hljs-keyword">Id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">Name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),    Age <span class="hljs-built_in">int</span>,    Address <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>))</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础</title>
    <link href="/2019/12/20/SQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/12/20/SQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>Structured Query Language 结构化查询语言</p><h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><ul><li>SQL语句对大小写不敏感。</li><li>某些数据库系统要求在每条 SQL 语句的末端使用分号。</li><li>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</li></ul><a id="more"></a><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>从数据库中选取数据</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table;// 从该表中选择所有列<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> my_table; // 从该表中选择id和name列</code></pre></div><h3 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h3><p>返回唯一不同的值</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> my_table; // 选择该表中的name列，并去掉重复值</code></pre></div><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><p>用于过滤记录</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'juzi'</span>;// 选取name为juzi的记录<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">where</span> <span class="hljs-keyword">sum</span>&lt;=<span class="hljs-number">10</span>;// 数值不使用单引号</code></pre></div><p>where子句中可以使用各种比较运算符，逻辑运算符，以及BETWEEN，LIKE，IN，IS NULL等特殊条件。</p><h3 id="AND-amp-OR"><a href="#AND-amp-OR" class="headerlink" title="AND &amp; OR"></a>AND &amp; OR</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'juzi'</span> <span class="hljs-keyword">AND</span> age &lt; <span class="hljs-number">18</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">'apple'</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">'banana'</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">where</span> country=<span class="hljs-string">'CHINA'</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">type</span>=<span class="hljs-string">'apple'</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">'banana'</span>);</code></pre></div><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>用于对结果进行排序</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> height; // 根据height排列，默认升序ASC<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> height <span class="hljs-keyword">DESC</span>; // 根据height降序排列</code></pre></div><p>根据多列进行排序</p><div class="hljs"><pre><code class="hljs sql">// 先根据age降序排列，再根据height局部升序排列<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>,height;</code></pre></div><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p>用于向表中插入新纪录</p><ul><li><p>没有指定列名，需要列出每一列的数据，自动更新的列，如id，不需要指定</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_table<span class="hljs-keyword">VALUES</span> (value1,value2,...)</code></pre></div></li><li><p>指定列插入数据</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_table (<span class="hljs-keyword">name</span>, age, height)<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'16'</span>, <span class="hljs-string">'168'</span>);</code></pre></div></li></ul><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>用于更新表中的记录</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> student<span class="hljs-keyword">SET</span> height=<span class="hljs-string">'190'</span>, age=<span class="hljs-string">'19'</span><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'apple'</span>;</code></pre></div><p>如果没有Where语句，将会更新表中的所有数据，应当小心使用！</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>用于删除表中的记录</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'apple'</span> <span class="hljs-keyword">AND</span> country=<span class="hljs-string">'CHINA'</span>;</code></pre></div><p>删除表中所有行</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> my_table;// 或者<span class="hljs-keyword">DELETE</span> * <span class="hljs-keyword">FROM</span> my_table;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo迁移</title>
    <link href="/2019/12/18/hexo%E8%BF%81%E7%A7%BB/"/>
    <url>/2019/12/18/hexo%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h1><ol><li><p>创建仓库Username.github.io；</p></li><li><p>创建两个分支：master和hexo，设置hexo为默认分支。master分支保存静态页面，hexo分支保存源文件；</p></li><li><p>将新仓库clone至本地，将先前hexo文件夹中的_config.yml，themes/，source/，scaffolds/，package.json，.gitignore文件复制至Username.github.io文件夹；</p></li></ol><a id="more"></a><ol start="4"><li><p>将主题文件中的.git删除，否则可能无法push；</p></li><li><p>执行<code>npm install</code> 和<code>npm install hexo-deployer-git</code> ；</p></li><li><p>执行<code>git add .</code> 、<code>git commit -m &quot;&quot;</code> 和<code>git push origin hexo</code> 来提交hexo网站源文件；</p></li><li><p>执行hexo g -d生成静态网页部署至Github上。</p></li></ol><h1 id="在新环境部署"><a href="#在新环境部署" class="headerlink" title="在新环境部署"></a>在新环境部署</h1><ol><li>安装git、npm、nodejs等；</li><li>添加ssh-keys<ul><li>在终端运行：<code>ssh-keygen -t rsa -C &quot;yourname@email.com&quot;</code>，一直按回车；</li><li>会在.ssh目录生成<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件，这就是密钥对，id_rsa是私钥；</li><li>登录Github，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容，注意不要粘贴成<code>id_rsa</code>，最后点击「Add SSH Key」。</li></ul></li><li>使用<code>git clone git@github.Username/Username.github.io.git</code>将仓库拷贝至本地；如果不是hexo分支，执行<code>git checkout hexo</code> 切换分支；</li><li>在文件夹内执行以下命令<code>npm install hexo-cli -g</code>、<code>npm install</code>和<code>npm install hexo-deployer-git</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发规范</title>
    <link href="/2019/09/24/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <url>/2019/09/24/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul><li><p>结构、样式、行为分离</p><p>文档和模板只包含HTML结构，样式都放到样式表里，行为放到脚本中</p></li><li><p>缩进</p><p>统一tab缩进或空格缩进，不混用</p><a id="more"></a></li><li><p>文件编码</p><p>使用不带 BOM 的 UTF-8 编码。</p><p>在 HTML中指定编码</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span></code></pre><p>无需使用 @charset 指定样式表的编码，它默认为 UTF-8 （参考 @charset）；</p></li><li><p>使用小写字母</p></li><li><p>省略外链资源URL协议部分</p><p>省略外链资源（图片及其它媒体资源）URL 中的 http / https 协议，使 URL 成为相对地址，避免Mixed Content 问题，减小文件字节数。 </p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--推荐--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//www.google.com"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>.example &#123;background:url("//www.google.com");&#125;<span class="hljs-comment">&lt;!--不推荐--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.google.com"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>.example &#123;background:url("https://www.google.com");&#125;</code></pre></li><li><p>统一注释，单行注释双斜线与文字之间保留一个空格</p><p>若至少三行注释时，第一行为/<code>*</code>，最后行为<code>*</code>/，其他行以<code>*</code>开始，并且注释文字与<code>*</code>保留一个空格。 </p></li><li><p>文件名不含空格，一般只使用小写字母，包含多个单词时使用半角连词符‘-’分隔</p></li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li><p>尽量减少标签数量</p></li><li><p>Class应以功能或内容命名</p></li><li><p>class与id单词字母小写，class采用下划线分割，id使用驼峰法命名</p></li><li><p>避免创建无样式信息的 class</p></li><li><p>HTML 属性应该按照特定的顺序出现以保证易读性</p><p>id，class，name，data-xxx，src, for, type, href，title, alt，aria-xxx, role</p></li><li><p>属性的定义，统一使用双引号</p></li><li><p>语义嵌套约束，严格嵌套约束</p></li><li><p>语义化</p><p>没有 CSS 的 HTML 是一个语义系统而不是 UI 系统。通常情况下，每个标签都是有语义的.语义化的 HTML 结构，有助于机器（搜索引擎）理解，另一方面多人协作时，能迅速了解开发者意图。</p></li><li><p>为每个HTML页面的第一行添加标准模式的声明</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></code></pre></li><li><p>lang属性的取值应该遵循 <a href="https://tools.ietf.org/html/bcp47" target="_blank" rel="noopener">BCP 47 - Tags for Identifying Languages</a>。 </p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--中文--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-Hans"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-comment">&lt;!--简体中文--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-cmn-Hans"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-comment">&lt;!--英文--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li><li><p>IE兼容模式</p><p>优先使用最新版本的IE 和 Chrome 内核。</p></li><li><p>viewport</p><p>为移动端设备优化，设置可见区域的宽度和初始缩放比例</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span></code></pre><p>viewport: 一般指的是浏览器窗口内容区的大小，不包含工具条、选项卡等内容；</p><p>width: 浏览器宽度，输出设备中的页面可见区域宽度；</p><p>device-width: 设备分辨率宽度，输出设备的屏幕可见宽度；</p><p>initial-scale: 初始缩放比例；</p><p>maximum-scale: 最大缩放比例；</p></li><li><p>favicon</p><p>在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证 favicon 可访问，避免404，必须遵循以下两种方法之一：</p><p>在 Web Server 根目录放置 favicon.ico 文件；使用 link 指定 favicon；</p></li><li><p>SEO优化</p></li><li><p>head模板</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"x-ua-compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge,chrome=1"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-comment">&lt;!--SEO--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"keywords"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"your keywords"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"your description"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"author,email address"</span>&gt;</span>    <span class="hljs-comment">&lt;!--为移动设备添加viewport--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span>    <span class="hljs-comment">&lt;!--favicon--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"favicon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>代码组织</p><p>以组件为单位组织代码段；</p><p>制定一致的注释规范；</p><p>组件块和子组件块以及声明块之间使用一空行分隔，子组件块之间三空行分隔；</p><p>如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动；</p><p>良好的注释是非常重要的。请留出时间来描述组件（component）的工作方式、局限性和构建它们的方法。不要让你的团队其它成员来猜测一段不通用或不明显的代码的目的。</p></li><li><p>避免选择器嵌套层级过多，尽量少于 3 级；</p><p>避免选择器和 Class、ID 叠加使用；</p><p>出于性能考量，在没有必要的情况下避免元素选择器叠加 Class、ID 使用</p></li><li><p>声明顺序</p><p>相关属性应为一组，推荐的样式编写顺序</p><p>Positioning</p><p>Box model</p><p>Typographic</p><p>Visual</p><p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型决定了组件的尺寸和位置，因此排在第二位。</p><p>其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。</p></li><li><p>媒体查询放在尽可能相关规则的附近 </p></li><li><p>不要使用 @import</p><p>与 <link> 相比，@import 要慢很多，不光增加额外的请求数，还会导致不可预料的问题。</p></li><li><p>慎重选择高消耗的样式</p><p>高消耗属性在绘制前需要浏览器进行大量计算：</p><p>box-shadows</p><p>border-radius</p><p>transparency</p><p>transforms</p><p>CSS filters</p></li><li><p>避免过分重排</p></li><li><p>正确使用Display的属性</p><p>Display 属性会影响页面的渲染，请合理使用。</p><p>display: inline后不应该再使用 width、height、margin、padding 以及 float；</p><p>display: inline-block 后不应该再使用 float；</p><p>display: block 后不应该再使用 vertical-align；</p><p>display: table-* 后不应该再使用 margin 或者 float；</p></li><li><p>不滥用float</p></li><li><p>动画性能优化</p><p>动画的基本概念：</p><p>帧：在动画过程中，每一幅静止画面即为一“帧”;</p><p>帧率：即每秒钟播放的静止画面的数量，单位是fps(Frame per second);</p><p>帧时长：即每一幅静止画面的停留时间，单位一般是ms(毫秒);</p><p>跳帧(掉帧/丢帧)：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续数帧被挤压而丢失的现象。</p><p>一般浏览器的渲染刷新频率是 60 fps，所以在网页当中，帧率如果达到 50-60 fps 的动画将会相当流畅，让人感到舒适。</p><p>如果使用基于 javaScript 的动画，尽量使用requestAnimationFrame. 避免使用 setTimeout, setInterval.</p><p>避免通过类似 jQuery animate()-style 改变每帧的样式，使用 CSS 声明动画会得到更好的浏览器优化。</p><p>使用 translate 取代 absolute 定位就会得到更好的 fps，动画会更顺滑。</p></li><li><p>3D或透视变换（perspective transform）CSS属性和对 opacity 进行 CSS 动画会创建新的图层，在硬件加速渲染通道的优化下，GPU 完成 3D 变形等操作后，将图层进行复合操作（Compesite Layers），从而避免触发浏览器大面积重绘和重排。使用 translate3d 右移 500px 的动画流畅度要明显优于直接使用 left</p></li><li><p>CSS 选择器是从右到左进行规则匹配。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的选择符，或者因为不匹配而退出。把最右边选择符称之为关键选择器。 </p><p>避免使用关键选择器是通配选择器的情况。</p><p>避免使用标签或class选择器限制id选择器</p><p>避免使用标签限制class选择器</p><p>避免使用多层标签选择器，使用class选择器替换，减少css查找</p><p>避免使用子选择器</p><pre><code class="hljs css"><span class="hljs-comment">/*不推荐*/</span><span class="hljs-selector-class">.tree</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>&#123;&#125;<span class="hljs-comment">/*推荐*/</span><span class="hljs-selector-class">.tree</span> &gt; <span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span>&#123;&#125;<span class="hljs-comment">/*非常推荐*/</span><span class="hljs-selector-class">.tree-li</span>&#123;&#125;</code></pre><p>使用继承</p><pre><code class="hljs css"><span class="hljs-comment">/*不推荐*/</span><span class="hljs-selector-tag">p</span> &gt; <span class="hljs-selector-tag">span</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125;<span class="hljs-comment">/*推荐*/</span><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125;</code></pre></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>没有必要，不加注释。有必要的注释写详尽。</li><li>单行注释必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。</li><li>避免使用 /…/ 这样的多行注释。有多行注释内容时，使用多个单行注释。</li></ul><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li>变量：驼峰式</li><li>私有属性、变量和方法以下划线_开头</li><li>函数，函数参数：驼峰式</li><li>类、枚举变量：Pascal命名法，每个单词首字母大写</li><li>常量、枚举属性：使用全部字母大写，单词间下划线分割</li></ul><h3 id="命名语法"><a href="#命名语法" class="headerlink" title="命名语法"></a>命名语法</h3><ul><li>类名使用名词</li><li>函数名使用动宾短语</li><li>boolean类型的变量使用is或has开头</li><li>Promise对象用动宾短语的进行时表示</li></ul><h3 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h3><ul><li>可读性强</li><li>尽量不使用缩写</li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><ul><li>类型检测优先使用typeof</li><li>对象检测使用instanceof</li><li>null 或 undefined 的检测使用 == null</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>对 Ajax 加载的 DOM 元素绑定事件时尽量使用事件委托。事件委托允许在父元素绑定事件，子代元素可以响应事件，也包括 Ajax 加载后添加的子代元素； </li></ul><h3 id="链式写法"><a href="#链式写法" class="headerlink" title="链式写法"></a>链式写法</h3><ul><li>尽量使用链式写法而不是用变量缓存或者多次调用选择器方法；</li><li>当链式写法超过三次或者因为事件绑定变得复杂后，使用换行和缩进保持代码可读性；</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>避免不必要的DOM操作</li><li>异步加载第三方内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++笔记</title>
    <link href="/2019/03/01/C++%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/03/01/C++%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h2><p>iostream：定义了读写流的基本类型</p><ul><li>istream，wistream 从流读取数据</li><li>ostream，wostream 从流写入数据</li><li>iostream，wiostream 读写流</li></ul><a id="more"></a><p>fstream：定义了读写命名文件的类型</p><ul><li>ifstream，wifstream 从文件读取数据</li><li>ofstream，wofstream 向文件写入数据</li><li>fstream，wfstream 读写文件</li></ul><p>sstream：定义了读写内存string对象的类型</p><ul><li>istringstream，wistringstream 从string读取数据</li><li>ostringstream，wostringstream 向string写入数据</li><li>stringstream，wstringstream 读写string</li></ul><p>IO对象无拷贝或赋值</p><p>条件状态（condition state）</p><pre><code class="hljs css"><span class="hljs-selector-tag">strm</span><span class="hljs-selector-pseudo">::iostate</span>提供了表达条件状态的完整功能<span class="hljs-selector-tag">strm</span><span class="hljs-selector-pseudo">::badbit</span>流已崩溃<span class="hljs-selector-tag">strm</span><span class="hljs-selector-pseudo">::failbit</span><span class="hljs-selector-tag">IO</span>操作失败<span class="hljs-selector-tag">strm</span><span class="hljs-selector-pseudo">::eofbit</span>流到达了文件末尾<span class="hljs-selector-tag">strm</span><span class="hljs-selector-pseudo">::goodbit</span>流未处于错误状态<span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.eof</span>()若流<span class="hljs-selector-tag">s</span>的<span class="hljs-selector-tag">eofbit</span>置位，返回<span class="hljs-selector-tag">true</span><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.fail</span>()若<span class="hljs-selector-tag">failbit</span>或<span class="hljs-selector-tag">badbit</span>置位，返回<span class="hljs-selector-tag">true</span><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.bad</span>()若<span class="hljs-selector-tag">badbit</span>置位，返回<span class="hljs-selector-tag">true</span><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.good</span>()若<span class="hljs-selector-tag">s</span>处于有效状态，返回<span class="hljs-selector-tag">true</span><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.clear</span>()将所有条件状态位复位，返回<span class="hljs-selector-tag">void</span><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.clear</span>(<span class="hljs-selector-tag">flags</span>)<span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.setstate</span>(<span class="hljs-selector-tag">flags</span>)<span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.rdstate</span>()返回当前条件状态</code></pre><p>刷新缓冲</p><p>unitbuf    每次输出后都刷新缓冲区</p><p>nounitbuf    重置流，使用正常的刷新机制</p><p>文件模式（file mode）</p><h2 id="顺序容器（sequential-container）"><a href="#顺序容器（sequential-container）" class="headerlink" title="顺序容器（sequential container）"></a>顺序容器（sequential container）</h2><pre><code class="hljs smali">vector可变大小数组，通常使用vectordeque双端队列list双向列表forward_list 单项列表array固定大小数组string字符容器，与vector类似</code></pre><p>迭代器范围（iterator range） [begin,end)</p><p>swap(c1,c2);    交换c1，c2中的元素</p><p>c1.swap(c2);    拷贝c2的元素</p><p>assign</p><p>push_back</p><p>push_front</p><p>insert</p><p>emplace_front</p><p>emplace</p><p>emplace_back</p><p>pop_back</p><p>pop_front</p><p>erase</p><p>clear</p><p>resize</p><p>capacity</p><p>shrink_to_fit</p><p>reserve</p><p>size</p><p>substr</p><p>compare</p><p>适配器（adaptor）</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows</title>
    <link href="/2019/02/23/windows/"/>
    <url>/2019/02/23/windows/</url>
    
    <content type="html"><![CDATA[<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-comment">/*其中包含了</span><span class="hljs-comment">WINDEF.H基本数据类型定义</span><span class="hljs-comment">WINNT.H支持Unicode的类型定义</span><span class="hljs-comment">WINBASE.H内核函数</span><span class="hljs-comment">WINUSER.H用户界面函数</span><span class="hljs-comment">WINGDI.H图像设备接口函数</span><span class="hljs-comment">等*/</span></code></pre><a id="more"></a><h3 id="程序入口函数：-WinMain-函数"><a href="#程序入口函数：-WinMain-函数" class="headerlink" title="程序入口函数： WinMain()函数"></a>程序入口函数： WinMain()函数</h3><pre><code class="hljs c"><span class="hljs-keyword">int</span>WINAPIWinMain(    HINSTANCE hInstance,<span class="hljs-comment">//实例句柄</span>    HINSTANCE hPrevInstance,    LPSTR lpCmdLine,    <span class="hljs-keyword">int</span> nShowCmd<span class="hljs-comment">//指明程序(窗口)最初如何被显示</span>    )</code></pre><p>句柄（handle）：在windows编程中，一个句柄是指使用一个唯一的整数值，即一个4字节（64位程序中位8字节）长的数值，来标识应用程序中的不同对象和同类中的不同的实例，如，桌面上的一个窗体由一个<code>HWND</code>类型的句柄来标识。 </p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="hljs-keyword">int</span> iCmdShow)</span></span><span class="hljs-function"></span>&#123;MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"Hello,world!"</span>), TEXT(<span class="hljs-string">"MessageBox"</span>), <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//出现一个显示helloworld的消息框</span></code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND hWnd,          <span class="hljs-comment">// handle of owner window, 窗口的一个句柄</span></span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,     <span class="hljs-comment">// address of text in message box, 一个文本(字符串)的指针</span></span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,  <span class="hljs-comment">// address of title of message box, 标题字符串的指针</span></span></span><span class="hljs-function"><span class="hljs-params">  UINT uType          <span class="hljs-comment">// style of message box, 对话框的风格</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><pre><code class="hljs c"><span class="hljs-comment">//对话框风格，可以使用OR(|)运算进行组合</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_OK                       0x00000000L            <span class="hljs-comment">//仅有一个"确定"按钮</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_OKCANCEL                 0x00000001L            <span class="hljs-comment">//"确定" + "取消"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ABORTRETRYIGNORE         0x00000002L            <span class="hljs-comment">//"终止" + "重试" + "忽略"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_YESNOCANCEL              0x00000003L            <span class="hljs-comment">//"是" + "否" + "取消"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_YESNO                    0x00000004L            <span class="hljs-comment">//"是" + "否"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_RETRYCANCEL              0x00000005L            <span class="hljs-comment">//"重试" + "取消"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONHAND                 0x00000010L            <span class="hljs-comment">//一个红X的错误/停止图标</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONQUESTION             0x00000020L            <span class="hljs-comment">//一个问号的询问图标</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONEXCLAMATION          0x00000030L            <span class="hljs-comment">//一个黄色感叹号的警告图标</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONASTERISK             0x00000040L            <span class="hljs-comment">//一个带有i的信息提示图标</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONWARNING              MB_ICONEXCLAMATION         <span class="hljs-comment">//警告</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONERROR                MB_ICONHAND                <span class="hljs-comment">//错误</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONINFORMATION          MB_ICONASTERISK            <span class="hljs-comment">//信息</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MB_ICONSTOP                 MB_ICONHAND                <span class="hljs-comment">//停止</span></span></code></pre><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">( HWND, UINT, WPARAM, LPARAM )</span> </span>;        <span class="hljs-comment">//声明用来处理消息的函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">( HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="hljs-keyword">int</span> iCmdShow )</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">static</span> TCHAR szAppName[] = TEXT(<span class="hljs-string">"MyWindow"</span>) ;    HWND hwnd ;    MSG msg ;    WNDCLASS wndclass ;        <span class="hljs-comment">//声明一个窗口类对象</span>    <span class="hljs-comment">//以下为窗口类对象wndclass的属性</span>    wndclass.style = CS_HREDRAW | CS_VREDRAW ;                         <span class="hljs-comment">//窗口样式</span>    wndclass.lpszClassName = szAppName ;                               <span class="hljs-comment">//窗口类名</span>    wndclass.lpszMenuName = <span class="hljs-literal">NULL</span> ;                                     <span class="hljs-comment">//窗口菜单:无</span>    wndclass.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH) ;    <span class="hljs-comment">//窗口背景颜色</span>    wndclass.lpfnWndProc = WndProc ;                                   <span class="hljs-comment">//窗口处理函数</span>    wndclass.cbWndExtra = <span class="hljs-number">0</span> ;                                          <span class="hljs-comment">//窗口实例扩展:无</span>    wndclass.cbClsExtra = <span class="hljs-number">0</span> ;                                          <span class="hljs-comment">//窗口类扩展:无</span>    wndclass.hInstance = hInstance ;                                   <span class="hljs-comment">//窗口实例句柄</span>    wndclass.hIcon = LoadIcon( <span class="hljs-literal">NULL</span>, IDI_APPLICATION ) ;               <span class="hljs-comment">//窗口最小化图标:使用缺省图标</span>    wndclass.hCursor = LoadCursor( <span class="hljs-literal">NULL</span>, IDC_ARROW ) ;                 <span class="hljs-comment">//窗口采用箭头光标</span>    <span class="hljs-keyword">if</span>( !RegisterClass( &amp;wndclass ) )    &#123;    <span class="hljs-comment">//注册窗口类, 如果注册失败弹出错误提示</span>        MessageBox( <span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"窗口注册失败!"</span>), TEXT(<span class="hljs-string">"错误"</span>), MB_OK | MB_ICONERROR ) ;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;    &#125;    hwnd = CreateWindow(                   <span class="hljs-comment">//创建窗口</span>                szAppName,                 <span class="hljs-comment">//窗口类名</span>                TEXT(<span class="hljs-string">"我的窗口"</span>),           <span class="hljs-comment">//窗口标题</span>                WS_OVERLAPPEDWINDOW,       <span class="hljs-comment">//窗口的风格</span>                CW_USEDEFAULT,             <span class="hljs-comment">//窗口初始显示位置x:使用缺省值</span>                CW_USEDEFAULT,             <span class="hljs-comment">//窗口初始显示位置y:使用缺省值</span>                CW_USEDEFAULT,             <span class="hljs-comment">//窗口的宽度:使用缺省值</span>                CW_USEDEFAULT,             <span class="hljs-comment">//窗口的高度:使用缺省值</span>                <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">//父窗口:无</span>                <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">//子菜单:无</span>                hInstance,                 <span class="hljs-comment">//该窗口应用程序的实例句柄 </span>                <span class="hljs-literal">NULL</span>                       <span class="hljs-comment">//</span>            ) ;    ShowWindow( hwnd, iCmdShow ) ;        <span class="hljs-comment">//显示窗口</span>    UpdateWindow( hwnd ) ;                <span class="hljs-comment">//更新窗口</span>    <span class="hljs-keyword">while</span>( GetMessage( &amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) )        <span class="hljs-comment">//从消息队列中获取消息</span>    &#123;        TranslateMessage( &amp;msg ) ;                 <span class="hljs-comment">//将虚拟键消息转换为字符消息</span>        DispatchMessage( &amp;msg ) ;                  <span class="hljs-comment">//分发到回调函数(过程函数)</span>    &#125;    <span class="hljs-keyword">return</span> msg.wParam ;&#125;<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )</span></span><span class="hljs-function"></span>&#123;    HDC hdc ;                <span class="hljs-comment">//设备环境句柄</span>    PAINTSTRUCT ps ;         <span class="hljs-comment">//绘制结构</span>    RECT <span class="hljs-built_in">rect</span>;               <span class="hljs-comment">//矩形结构</span>    <span class="hljs-keyword">switch</span>( message )        <span class="hljs-comment">//处理得到的消息</span>    &#123;    <span class="hljs-keyword">case</span> WM_CREATE:          <span class="hljs-comment">//窗口创建完成时发来的消息</span>        MessageBox( hwnd, TEXT(<span class="hljs-string">"窗口已创建完成!"</span>), TEXT(<span class="hljs-string">"我的窗口"</span>), MB_OK | MB_ICONINFORMATION ) ;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">case</span> WM_PAINT:           <span class="hljs-comment">//处理窗口区域无效时发来的消息</span>        hdc = BeginPaint( hwnd, &amp;ps ) ;        GetClientRect( hwnd, &amp;<span class="hljs-built_in">rect</span> ) ;        DrawText( hdc, TEXT( <span class="hljs-string">"Hello, 这是我自己的窗口!"</span> ), <span class="hljs-number">-1</span>, &amp;<span class="hljs-built_in">rect</span>, DT_SINGLELINE | DT_CENTER | DT_VCENTER ) ;        EndPaint( hwnd, &amp;ps ) ;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;    <span class="hljs-keyword">case</span> WM_LBUTTONDOWN:     <span class="hljs-comment">//处理鼠标左键被按下的消息</span>        MessageBox( hwnd, TEXT(<span class="hljs-string">"鼠标左键被按下。"</span>), TEXT(<span class="hljs-string">"单击"</span>), MB_OK | MB_ICONINFORMATION ) ;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">case</span> WM_DESTROY:         <span class="hljs-comment">//处理窗口关闭时的消息</span>        MessageBox( hwnd, TEXT(<span class="hljs-string">"关闭程序!"</span>), TEXT(<span class="hljs-string">"结束"</span>), MB_OK | MB_ICONINFORMATION ) ;        PostQuitMessage( <span class="hljs-number">0</span> ) ;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> DefWindowProc( hwnd, message, wParam, lParam ) ;        <span class="hljs-comment">//DefWindowProc处理我们自定义的消息处理函数没有处理到的消息</span>&#125;</code></pre><p><a href="https://www.cnblogs.com/mr-wid/archive/2012/10/09/2717278.html" target="_blank" rel="noopener">https://www.cnblogs.com/mr-wid/archive/2012/10/09/2717278.html</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/2019/02/22/C-%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/02/22/C-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">//#include&lt;istream&gt;</span><span class="hljs-comment">//#include&lt;ostream&gt;</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//::作用域运算符</span></code></pre><a id="more"></a><pre><code class="hljs c++"><span class="hljs-comment">//读取数量不定的输入数据</span><span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;value)    sum+=value;</code></pre><h3 id="类-class"><a href="#类-class" class="headerlink" title="类  class"></a>类  class</h3><p>成员函数（member function） -  方法（method）</p><h3 id="类型-type"><a href="#类型-type" class="headerlink" title="类型 type"></a>类型 type</h3><p>基本数据类型（base type） </p><p>算术类型（arithmetic type）：包括整型（integral type）和浮点型</p><p>空类型（void）</p><p>signed 带符号的</p><p>unsigned 无符号的</p><pre><code class="hljs c++"><span class="hljs-number">20</span><span class="hljs-comment">//十进制</span><span class="hljs-number">024</span><span class="hljs-comment">//八进制</span><span class="hljs-number">0x14</span><span class="hljs-comment">//十六进制</span>    <span class="hljs-string">'a'</span><span class="hljs-comment">//字符字面值</span><span class="hljs-string">"Hello World"</span> <span class="hljs-comment">//字符串总面值</span></code></pre><p>转义序列（escape sequence）</p><p>换行符        \n            横向制表符        \t            报警（响铃）符        \a</p><p>纵向制表符    \v            退格符            \b            双引号                &quot;</p><p>反斜线        \            问号                ?            单引号                &#39;</p><p>回车符        \r            进纸符            \f</p><p>变量（variable）</p><p>类型说明符（type specifier)</p><p>对象（object）</p><p>初始化（initialized)</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//&#123;&#125;初始化变量，叫做列表初始化（list initialization)</span><span class="hljs-comment">//但当初始值存在丢失信息的风险时，编译器将报错</span></code></pre><p>默认初始化（default initialized)</p><p>定义在函数体内部的内置类型变量将不被初始化（uninitialized）</p><p>分离式编译（separate compilation）：允许将程序分割为若干个文件，每个文件单独编译</p><p>声明（declaration）</p><p>定义（definition）</p><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//声明i</span><span class="hljs-keyword">int</span> i;<span class="hljs-comment">//声明并定义i</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">//定义，抵消了extern的作用</span><span class="hljs-comment">/*在多个文件中使用同一个变量时，必须将声明和定义分离，变量的定义只能出现在一个文件中，其他用到该变量的文件必须对其声明，但不能重复定义*/</span></code></pre><p>标识符（identifier）： 字母，下划线，数字组成</p><p>变量名：小写</p><p>类名：大写字母开头</p><p>单词间有明显区分：student_loan或studentLoan</p><p>作用域（scope）：大多数作用域以{}分隔</p><p>全局作用域（global scope）</p><p>块作用域（block scope）</p><p>内层作用域（inner scope）</p><p>外层作用域（outer scope）</p><h3 id="复合类型（compound-type）"><a href="#复合类型（compound-type）" class="headerlink" title="复合类型（compound type）"></a>复合类型（compound type）</h3><p>引用（reference）：定义引用时，程序将引用和初始值绑定（bind）在一起，即别名，引用必须初始化</p><p>指针（pointer）：存放某个对象的地址，本身也是个对象</p><p>const限定符</p><p>const对象一旦创建后其值不能再改变，必须初始化。</p><p>常量表达式（const expression）</p><p>constexpr：声明为constexpr的变量一定是一个常量，且必须用常量表达式初始化</p><p>字面值类型（literal type)</p><p>类型别名（type alias）</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages;<span class="hljs-comment">//wages是double的别名</span></code></pre><p>别名声明（alias declaration）</p><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = Sales_item;<span class="hljs-comment">//SI是Sales_item的别名</span></code></pre><p>auto类型说明符：让编译器分析表达式所属类型</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;</code></pre><p>decltype：选择并返回操作数的数据类型，不实际计算表达式的值</p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>;<span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;<span class="hljs-comment">//xp类型为const int</span><span class="hljs-keyword">decltype</span>(f()) sum = x; <span class="hljs-comment">//sum的类型是f的返回类型，并不实际调用函数f</span></code></pre><p>自定义数据结构</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sale_data</span> &#123;</span><span class="hljs-comment">/* ... */</span>&#125; accum, trans, *salesptr;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sale_data</span> &#123;</span><span class="hljs-comment">/* ... */</span>&#125;;</code></pre><p>数据成员（data member）</p><p>类内初始值（in-class initializer）</p><p>预处理器（preprocessor）</p><p>头文件</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SALES_DATA_H<span class="hljs-comment">//变量未定义时为真，为真时执行后续操作直到#endif（#ifdef变量已定义为真）</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SALES_DATA_H<span class="hljs-comment">//将该名字设定为预处理变量</span></span><span class="hljs-comment">/*</span><span class="hljs-comment">......</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>using</p><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::name;<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>;<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</code></pre><h3 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 string</h3><p>表示可变长的字符序列</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;<span class="hljs-built_in">string</span> s1;<span class="hljs-comment">//默认，空字符串</span><span class="hljs-built_in">string</span> s2 = s1;<span class="hljs-comment">//stirng s2(s1);</span><span class="hljs-built_in">string</span> s3 = <span class="hljs-string">"hiya"</span>;<span class="hljs-comment">//string s3("hiya");</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">'c'</span>)</span></span>;<span class="hljs-comment">//cccccccccc</span></code></pre><pre><code class="hljs c++">getline(is,s);<span class="hljs-comment">//读取一整行</span>s.empty();s.<span class="hljs-built_in">size</span>();s[n];<span class="hljs-comment">//== != &lt;= &lt; &gt;= &gt;</span></code></pre><h3 id="C标准库String"><a href="#C标准库String" class="headerlink" title="C标准库String"></a>C标准库String</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;//string.h的c++版本</span></span><span class="hljs-built_in">strlen</span>(p);<span class="hljs-built_in">strcmp</span>(p1,p2);<span class="hljs-comment">//p1==p2 return 0; p1&gt;p2 return 正值；p1&lt;p2 return 负值；</span><span class="hljs-built_in">strcat</span>(p1,p2);<span class="hljs-comment">//p2加到p1后</span><span class="hljs-built_in">strcpy</span>(p1,p2);<span class="hljs-comment">//p2拷贝给p1</span></code></pre><h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h3><p>被称为容器（container）</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">//保存int类型的对象</span><span class="hljs-built_in">vector</span>&lt;Sales_item&gt; Sales_vec;<span class="hljs-comment">//保存Sales_item的对象</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; file;<span class="hljs-comment">//保存vector的对象</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; articles = &#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"an"</span>, <span class="hljs-string">"the"</span>&#125;;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; a1&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"an"</span>, <span class="hljs-string">"the"</span>&#125;;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">a2</span><span class="hljs-params">(a1)</span></span>; <span class="hljs-comment">//a2 = a1;</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//10个0</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//10个1</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3&#123;<span class="hljs-number">10</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//10和1</span><span class="hljs-comment">/*使用了&#123;&#125;，但提供的值又不能执行列表初始化，所以考虑用所给值构造对象*/</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v4&#123;<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//10个默认初始化元素</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v5&#123;<span class="hljs-number">10</span>,<span class="hljs-string">"hi"</span>&#125;;<span class="hljs-comment">//10个"hi"</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=<span class="hljs-number">100</span>;i++)    v1.push_back(i);<span class="hljs-comment">//把整数值放到尾端</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:v1)    <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//使用数组初始化容器</span><span class="hljs-keyword">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-built_in">begin</span>(int_arr), <span class="hljs-built_in">end</span>(int_arr))</span></span>;</code></pre><h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> b = v.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//b表示的迭代器指向v的第一个元素</span><span class="hljs-keyword">auto</span> e = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//e表示的迭代器指向v尾元素的下一个位置 </span><span class="hljs-comment">//end成员返回的是尾后迭代器（off-the-end iterator）</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=s.<span class="hljs-built_in">begin</span>(); it!=s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*it); ++it)    *it = <span class="hljs-built_in">toupper</span>(*it);<span class="hljs-comment">//改成大写</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-comment">//it能读写vector&lt;int&gt;的元素</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it2;<span class="hljs-comment">//只能读，不能写</span><span class="hljs-comment">//解引用</span>*it</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>字符数组结尾需要有一个位置存放空字符</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">int</span> b[] = a;<span class="hljs-comment">//错误，不允许使用一个数组初始化另一个数组</span>b = a;<span class="hljs-comment">//错误，不允许把一个数组直接赋值给另一个数组</span><span class="hljs-built_in">string</span> nums[] = &#123;<span class="hljs-string">"one"</span>,<span class="hljs-string">"two"</span>,<span class="hljs-string">"three"</span>&#125;;<span class="hljs-built_in">string</span> *p = &amp;nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//p指向nums的第一个元素 等价于 string *p = nums;</span>++p;<span class="hljs-comment">//p指向nums[1]</span><span class="hljs-keyword">int</span> ia[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<span class="hljs-comment">//第一行</span>    &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<span class="hljs-comment">//第二行</span>&#125;</code></pre><p>一元运算符（unary operator）</p><p>二元运算符（binary operator）</p><p>优先级（precedence)</p><p>结合律（associativity）</p><p>重载运算符（overloaded operator)</p><p>右值（rvalue）</p><p>左值（lvalue）</p><p>位运算符</p><pre><code class="hljs c++">~位求反<span class="hljs-number">1</span>变<span class="hljs-number">0</span>,<span class="hljs-number">0</span>变<span class="hljs-number">1</span>&lt;&lt;左移右侧插入<span class="hljs-number">0</span>，超出边界的位丢弃&gt;&gt;右移无符号数左侧插入<span class="hljs-number">0</span>，有符号数左侧插入符号位的副本或值为<span class="hljs-number">0</span>的二进制位&amp;位与全<span class="hljs-number">1</span>为<span class="hljs-number">1</span>^位异或有且只有一个<span class="hljs-number">1</span>，为<span class="hljs-number">1</span>|位或有<span class="hljs-number">1</span>为<span class="hljs-number">1</span></code></pre><p>sizeof    返回一条表达式或一个类型名字所占的字节数</p><p>类型转换</p><p>隐式转换（implicit conversion）</p><p>算术转换（arithmetic conversion）</p><p>整数提升（integral promotion）</p><p>强制类型转换（cast）</p><p>形参（parameter）</p><p>实参（argument）</p><p>自动对象（automatic object）</p><p>局部静态对象（local static object）</p><p>函数原型（function prototype）</p><p>引用传递（passed by reference）</p><p>传引用调用（called by reference）</p><p>值传递（passed by value）</p><p>传值调用（called by value）</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i)</span><span class="hljs-comment">//i是传给reset函数的对象的另一个名字</span></span><span class="hljs-function"></span>&#123;    i=<span class="hljs-number">0</span>;<span class="hljs-comment">//改变了i所引用的对象</span>&#125;<span class="hljs-comment">//使用引用避免拷贝</span><span class="hljs-comment">//如果函数无须改变引用形参的值，最好将其声明为常量引用</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();&#125;</code></pre><p>重载（overloaded）函数</p><p>默认实参（default argument）</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz ht=<span class="hljs-number">24</span>,sz wid=<span class="hljs-number">22</span>,<span class="hljs-keyword">char</span> back=<span class="hljs-string">' '</span>)</span></span>;</code></pre><p>内联函数（inline）</p><p>constexpr函数</p><p>assert预处理宏（preprocessor marco）</p><pre><code class="hljs c++"><span class="hljs-comment">//expr为真，什么也不做，expr为假，输出信息并终止程序</span>assert(expr);</code></pre><p>NDEBUG预处理变量</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NDEBUG</span><span class="hljs-comment">//定义后将关闭调试状态，assert什么也不做</span></code></pre><p>函数指针</p><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;);<span class="hljs-comment">//pf是指向函数的指针，返回值是bool</span><span class="hljs-keyword">bool</span> b1 = pf(<span class="hljs-string">"hello"</span>,<span class="hljs-string">"goodbye"</span>);<span class="hljs-keyword">bool</span> b2 = (*pf)(<span class="hljs-string">"hello"</span>,<span class="hljs-string">"goodbye"</span>);</code></pre><p>数据抽象（data abstraction）</p><p>封装（encapsulation）</p><p>抽象数据类型（abstract data type）</p><p>成员函数（member function）</p><p>常量成员函数（const member function）</p><p>构造函数（constructor）：初始化对象的数据成员</p><p>默认构造函数（default constructor）：没有显式的定义构造函数时，编译器自动生成。如果存在类内初始值，用它来初始化成员，否则，默认初始化该成员</p><pre><code class="hljs c++"><span class="hljs-comment">//既需要其他形式的构造函数，也需要默认的构造函数时，使用该语句</span>Sales_data() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//默认构造函数</span><span class="hljs-comment">//如果定义了其他构造函数，最好也提供一个默认构造函数</span></code></pre><p>构造函数初始值列表（constructor initialize list）</p><pre><code class="hljs c++"><span class="hljs-comment">//外部定义构造函数</span>Sales_data::Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is)&#123;    <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);&#125;</code></pre><p>编译器会替我们合成拷贝、赋值和销毁的操作，但对于某些类来说，合成的版本无法正常工作。</p><p>访问说明符（access specifiers）：加强类的封装性</p><p>public</p><p>private</p><p>使用class和struct定义类的唯一区别就是默认的访问权限，class成员的默认访问权限是private，struct成员的默认访问权限是public。</p><p>友元（friend）：允许其他类或者函数访问它的非公有成员</p><p>一般来说，最好在类定义开始或结束前的位置集中声明友元</p><p>内联函数inline</p><p>可变数据成员（mutable data member）</p><pre><code class="hljs c++"><span class="hljs-comment">//前向声明（forward declaration），仅声明类而暂时不定义它</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>;</span><span class="hljs-comment">//不完全类型（incomplete type）</span></code></pre><p>名字查找（name lookup）：</p><ul><li>首先，在名字所在的块中寻找声明语句，只考虑在名字的使用之前出现的声明</li><li>如果没找到，继续查找外层作用域</li><li>未找到匹配的声明，报错</li></ul><p>委托构造函数（delegating constructor)：一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。</p><p>转换构造函数（converting constructor）</p><p>explicit：抑制构造函数定义的隐式转换</p><p>聚合类（aggregate class）</p><ul><li>所有的成员都是public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，没有virtual函数</li></ul><p>static：声明静态成员</p><pre><code class="hljs c++"><span class="hljs-comment">//使用作用域运算符访问静态成员</span>r = Account::rate();<span class="hljs-comment">//成员函数可以直接使用静态成员</span><span class="hljs-comment">//静态数据成员不属于类的对象，一般必须在类的外部定义和初始化每个静态成员</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D数学基础</title>
    <link href="/2018/12/31/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/12/31/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>坐标范围（coordinate extent）：对象的x，y，z最小值和最大值等信息，也称为对象的包围盒（bounding box）</p><p>包围矩形（bounding rectangle)：2维</p><p>世界坐标系(World coordinate system) </p><p>物体坐标系</p><p>惯性坐标系（inertial frame of reference ）：原点与物体坐标系重合，轴平行于世界坐标系。</p><p>摄像机坐标系(Camera coordinate system) </p><p>屏幕坐标（screen coordinate）</p><p>绝对坐标（absolute coordinate）</p><p>相对坐标（relative coordinate）</p><p>齐次坐标（homogeneous-coordinate）</p><p>//———————————————————————————————</p><p>光栅化算法生成的图元显示具有锯齿状或阶梯状外观</p><p>走样（aliasing）：这种由于低频取样（不完全取样）而造成的信息丢失称为走样</p><p>反走样（antialiasing）</p><p>属性组（attribute group）</p><p>点属性组（point-attribute group）</p><p>线属性组（line-attribute group）</p><p>多边形属性组（polygon-attribute group）</p><p>//—————————————————————————————————-</p><h3 id="欧拉角（EulerAngles）"><a href="#欧拉角（EulerAngles）" class="headerlink" title="欧拉角（EulerAngles）"></a>欧拉角（EulerAngles）</h3><p>在物体坐标系，根据左手法则</p><p>heading - 绕y轴，从y轴正方向向原点看，顺时针方向为正</p><p>pitch - 绕x轴，从x轴正方向向原点看，顺时针方向为正</p><p>bank - 绕z轴，从z轴正方向向原点看，顺时针方向为正</p><p>旋转顺序为heading-pitch-bank时，指从惯性坐标系到物体坐标系，从物体坐标系到惯性坐标系时，旋转顺序相反</p><p>roll-pitch-yaw系统，角度命名顺序与从物体坐标系到惯性坐标系的旋转顺序一致</p><p>万向锁（Gimbel lock）</p><p><a href="http://v.youku.com/v_show/id_XNzkyOTIyMTI=.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XNzkyOTIyMTI=.html</a></p><p>让欧拉角处于限制集里：heading和bank在-180度到180度，pitch在-90度到90度。</p><h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>[w,(x,y,z)]</p><pre><code class="hljs c++">w = <span class="hljs-built_in">cos</span>(theta/<span class="hljs-number">2</span>)    x  = ax * <span class="hljs-built_in">sin</span>(theta/<span class="hljs-number">2</span>)    y  = ay * <span class="hljs-built_in">sin</span>(theta/<span class="hljs-number">2</span>)    z  = az * <span class="hljs-built_in">sin</span>(theta/<span class="hljs-number">2</span>)</code></pre><p>(ax,ay,az)表示轴的矢量，theta表示绕此轴的旋转角度 </p><p>单位四元数: [1,(0,0,0)]</p><p>四元数的模：sqrt(w^2 + x^2 + y^2 + z^2)</p><p>//————————————————————————————————————</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>openGL</title>
    <link href="/2018/11/17/openGL/"/>
    <url>/2018/11/17/openGL/</url>
    
    <content type="html"><![CDATA[<h3 id="核心模式和立即渲染模式"><a href="#核心模式和立即渲染模式" class="headerlink" title="核心模式和立即渲染模式"></a>核心模式和立即渲染模式</h3><p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线）。</p><p>OpenGL3.2开始，规范文档开始废弃立即渲染模式，鼓励开发者在OpenGL的核心模式（Core-profile）下进行开发。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。 </p><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(GL_ARB_extension_name)&#123;    <span class="hljs-comment">// 使用硬件支持的全新的现代特性</span>&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">// 不支持此扩展: 用旧的方式去做</span>&#125;</code></pre><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>OpenGL自身是一个巨大的状态机（State Machine）：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL的上下文（Context）。</p><p>通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。 </p><p>状态设置函数(State-changing Function)，这类函数将会改变上下文。</p><p>状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。 </p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。 </p><p>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。 </p><p>来源：<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaScript语法</title>
    <link href="/2018/07/05/javaScript%E8%AF%AD%E6%B3%95/"/>
    <url>/2018/07/05/javaScript%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 数值：转换后还是原来的值</span><span class="hljs-built_in">Number</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">// 324</span><span class="hljs-comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><span class="hljs-built_in">Number</span>(<span class="hljs-string">'324'</span>) <span class="hljs-comment">// 324</span><span class="hljs-comment">// 字符串：如果不可以被解析为数值，返回 NaN</span><span class="hljs-built_in">Number</span>(<span class="hljs-string">'324abc'</span>) <span class="hljs-comment">// NaN</span><span class="hljs-comment">// 空字符串转为0</span><span class="hljs-built_in">Number</span>(<span class="hljs-string">''</span>) <span class="hljs-comment">// 0</span><span class="hljs-comment">// 布尔值：true 转成 1，false 转成 0</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><span class="hljs-comment">// undefined：转成 NaN</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><span class="hljs-comment">// null：转成0</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><span class="hljs-built_in">Number</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// NaN</span><span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><span class="hljs-built_in">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'42 cats'</span>) <span class="hljs-comment">// 42</span><span class="hljs-built_in">Number</span>(<span class="hljs-string">'42 cats'</span>) <span class="hljs-comment">// NaN</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'\t\v\r12.34\n'</span>) <span class="hljs-comment">// 12</span><span class="hljs-built_in">Number</span>(<span class="hljs-string">'\t\v\r12.34\n'</span>) <span class="hljs-comment">// 12.34</span><span class="hljs-built_in">String</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// "123"</span><span class="hljs-built_in">String</span>(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">// "abc"</span><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// "true"</span><span class="hljs-built_in">String</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// "undefined"</span><span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// "null"</span><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// "[object Object]"</span><span class="hljs-built_in">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// "1,2,3"</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">''</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><span class="hljs-built_in">Boolean</span>([]) <span class="hljs-comment">// true</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span></code></pre><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><pre><code class="hljs javascript"><span class="hljs-number">123</span> + <span class="hljs-string">'abc'</span> <span class="hljs-comment">// "123abc"</span><span class="hljs-keyword">if</span> (<span class="hljs-string">'abc'</span>) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)&#125;  <span class="hljs-comment">// "hello"</span>+ &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>&#125; <span class="hljs-comment">// NaN</span>- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// NaN</span><span class="hljs-string">'5'</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// '51'</span><span class="hljs-string">'5'</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// "5true"</span><span class="hljs-string">'5'</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// "5false"</span><span class="hljs-string">'5'</span> + &#123;&#125; <span class="hljs-comment">// "5[object Object]"</span><span class="hljs-string">'5'</span> + [] <span class="hljs-comment">// "5"</span><span class="hljs-string">'5'</span> + <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-comment">// "5function ()&#123;&#125;"</span><span class="hljs-string">'5'</span> + <span class="hljs-literal">undefined</span> <span class="hljs-comment">// "5undefined"</span><span class="hljs-string">'5'</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// "5null"</span><span class="hljs-keyword">var</span> obj = &#123;  width: <span class="hljs-string">'100'</span>&#125;;obj.width + <span class="hljs-number">20</span> <span class="hljs-comment">// "10020"</span><span class="hljs-string">'5'</span> - <span class="hljs-string">'2'</span> <span class="hljs-comment">// 3</span><span class="hljs-string">'5'</span> * <span class="hljs-string">'2'</span> <span class="hljs-comment">// 10</span><span class="hljs-literal">true</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><span class="hljs-literal">false</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// -1</span><span class="hljs-string">'1'</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// 0</span><span class="hljs-string">'5'</span> * []    <span class="hljs-comment">// 0</span><span class="hljs-literal">false</span> / <span class="hljs-string">'5'</span> <span class="hljs-comment">// 0</span><span class="hljs-string">'abc'</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// NaN</span><span class="hljs-literal">null</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// NaN</span>+<span class="hljs-string">'abc'</span> <span class="hljs-comment">// NaN</span>-<span class="hljs-string">'abc'</span> <span class="hljs-comment">// NaN</span>+<span class="hljs-literal">true</span> <span class="hljs-comment">// 1</span>-<span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span></code></pre><h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'出错了'</span>);err.message <span class="hljs-comment">// "出错了"</span><span class="hljs-comment">//SyntaxError 解析代码时发生的语法错误</span><span class="hljs-comment">//ReferenceError 引用一个不存在的变量时发生的错误</span><span class="hljs-comment">//RangeError 一个值超出有效范围时发生的错误</span><span class="hljs-comment">//TypeError 变量或参数不是预期类型时发生的错误</span><span class="hljs-comment">//URIError URI相关函数的参数不正确时抛出的错误</span><span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'x 必须为正数'</span>);&#125;<span class="hljs-comment">//throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。</span><span class="hljs-comment">//遇到throw语句，程序就中止了</span><span class="hljs-comment">// 抛出一个字符串</span><span class="hljs-keyword">throw</span> <span class="hljs-string">'Error！'</span>;<span class="hljs-comment">// Uncaught Error！</span><span class="hljs-comment">// 抛出一个数值</span><span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>;<span class="hljs-comment">// Uncaught 42</span><span class="hljs-comment">// 抛出一个布尔值</span><span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// Uncaught true</span><span class="hljs-comment">// 抛出一个对象</span><span class="hljs-keyword">throw</span> &#123;  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'Error!'</span>;  &#125;&#125;;<span class="hljs-comment">// Uncaught &#123;toString: ƒ&#125;</span><span class="hljs-comment">/*try代码块抛出错误，JavaScript引擎立即把代码的执行，转到catch代码块，catch接受一个参数，表示try代码块抛出的值*/</span><span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'出错了!'</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;  <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">": "</span> + e.message);  <span class="hljs-built_in">console</span>.log(e.stack);&#125;<span class="hljs-comment">//try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句</span>openFile();<span class="hljs-keyword">try</span> &#123;  writeFile(Data);&#125; <span class="hljs-keyword">catch</span>(e) &#123;  handleError(e);&#125; <span class="hljs-keyword">finally</span> &#123;  closeFile();&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAction</span>(<span class="hljs-params">action</span>) </span>&#123;  <span class="hljs-keyword">var</span> actions = &#123;    <span class="hljs-string">'hack'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">'hack'</span>;    &#125;,    <span class="hljs-string">'slash'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">'slash'</span>;    &#125;,    <span class="hljs-string">'run'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">'run'</span>;    &#125;  &#125;;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actions[action] !== <span class="hljs-string">'function'</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid action.'</span>);  &#125;  <span class="hljs-keyword">return</span> actions[action]();&#125;<span class="hljs-comment">//switch..case结构建议用对象结构代替</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADT</title>
    <link href="/2018/06/26/ADT/"/>
    <url>/2018/06/26/ADT/</url>
    
    <content type="html"><![CDATA[<h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><ul><li>Abstract Data Type – 抽象数据类型</li></ul><a id="more"></a><ul><li>是计算机科学中具有类似行为的特定类别的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">数据结构</a>的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">数学模型</a>；或者具有类似语义的一种或多种<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">程序设计语言</a>的<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B" target="_blank" rel="noopener">数据类型</a>。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。 </li><li>抽象数据类型（ADT）是纯粹理论实体，用于简化描述抽象算法，分类与评价数据结构，形式描述程序设计语言的类型系统。一个ADT可以用特定数据类型或数据结构实现，在许多程序设计语言中有许多种实现方式；或者用形式规范语言描述。ADT常实现为模块（module）：模块的接口声明了对应于ADT操作的例程（procedure），有时用注释描述了约束。 </li><li>实现于程序时，抽象数据类型只显现出其接口，并将实现加以隐藏。用户只需关心它的接口，而不是如何实现。 </li></ul><p>数据对象集</p><p>数据关系集：数据对象的组织方式</p><p>操作集</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2018/06/13/Vim/"/>
    <url>/2018/06/13/Vim/</url>
    
    <content type="html"><![CDATA[<p>vimtutor  进入教程</p><p>h – 左移</p><p>j – 下移</p><p>k – 上移</p><p>l – 右移</p><a id="more"></a><p>ESC – 回到正常模式</p><p>:q!  丢弃进入编辑器以来的改动，强制退出</p><p>:wq 保存文件并退出</p><p>0（零）– 移动光标到行首</p><p>w – 从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符</p><p>e - 从当前光标当前位置直到单词末尾，包括最后一个字符</p><p>$ - 从当前光标当前位置直到当前行末</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>i – 在当前光标插入文本</p><p>I（大写i）– 跳转到行首插入文本</p><p>a – 在当前光标后插入</p><p>A – 跳转到行末插入</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>x – 删除光标所在位置的字符</p><p>dw – 从光标处删除到下一个单词的起始处</p><p>d$ – 从当前光标删除到行末</p><p>d0 – 删除该行中当前光标前的内容</p><p>de – 从光标处删除到一个单词的末尾</p><p>dd – 删除整行</p><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>在动作前输入数字来重复动作</p><p>3w – 光标向前移动3个单词</p><p>2j – 光标向下移动2行</p><p>d2d（2dd）– 删除两行</p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>u – 撤销最后执行的命令</p><p>U – 撤销对整行的修改</p><p>Ctrl+R – 撤销以前的撤销命令</p><h4 id="置入"><a href="#置入" class="headerlink" title="置入"></a>置入</h4><p>p – 将最后一次删除的内容置入光标之后</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>r+要替换成的字符 – 将当前光标的内容替换成输入的字符</p><h4 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h4><p>cw（ce）– 删除光标后内容直到该单词末尾，并进入插入模式</p><p>c$</p><p>c0</p><p>cc – 删除整行并进入插入模式</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高德地图API</title>
    <link href="/2018/06/12/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEAPI/"/>
    <url>/2018/06/12/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEAPI/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs armasm">地图容器 Container图层 Layers矢量图形 Vector Overlays点标记 <span class="hljs-keyword">Markers </span> 圆点标记 (CircleMarker) 、文本标记 (Text)、灵活点标记 (ElasticMarker) 海量点（MassMarks）、点聚合（<span class="hljs-keyword">MarkerCluster）</span><span class="hljs-keyword">地图控件 </span><span class="hljs-meta">Map</span> Controls插件 Plugins地图级别 ZoomLevel经纬度 LngLat底图 <span class="hljs-keyword">BaseLayer</span><span class="hljs-keyword">地图要素 </span><span class="hljs-meta">Map</span> Features标注 Labels地图平面像素坐标 Plane Coordinates投影 Projection三维空间坐标 <span class="hljs-number">3</span>D Coordinates</code></pre><a id="more"></a><p>基础类</p><pre><code class="hljs javascript"><span class="hljs-comment">//经纬度AMap.LngLat,lng经度，lat纬度</span><span class="hljs-keyword">var</span> position = <span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">116</span>, <span class="hljs-number">39</span>);<span class="hljs-comment">//标准写法</span><span class="hljs-keyword">var</span> position = [<span class="hljs-number">116</span>, <span class="hljs-number">39</span>]; <span class="hljs-comment">//简写</span><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> AMap.Center(<span class="hljs-string">'conatiner'</span>,&#123;    center:position&#125;)<span class="hljs-comment">//经纬度数组</span><span class="hljs-keyword">var</span> path = [<span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">116</span>,<span class="hljs-number">39</span>), <span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">116</span>,<span class="hljs-number">40</span>), <span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">117</span>,<span class="hljs-number">39</span>)] <span class="hljs-comment">//标准写法</span><span class="hljs-keyword">var</span> path = [ [<span class="hljs-number">116</span>,<span class="hljs-number">39</span>], [<span class="hljs-number">116</span>,<span class="hljs-number">40</span>], [<span class="hljs-number">117</span>,<span class="hljs-number">39</span>] ]; <span class="hljs-comment">//简写</span><span class="hljs-comment">//经纬度计算</span><span class="hljs-keyword">var</span> distance = lnglat1.distance(lnglat2);<span class="hljs-comment">//计算lnglat1到lnglat2之间的实际距离(m)</span><span class="hljs-keyword">var</span> lnglat3 = lnglat1.offset(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>)<span class="hljs-comment">//lnglat1向东100m，向北50m的位置的经纬度</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//像素点 AMap.Pixel</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//像素尺寸 AMap.Size</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//经纬度矩形边界 AMap.Bounds</span><span class="hljs-comment">//经纬度路径边界 AMap.ArrayBounds</span></code></pre><h3 id="地图生命周期：创建、存在、销毁"><a href="#地图生命周期：创建、存在、销毁" class="headerlink" title="地图生命周期：创建、存在、销毁"></a>地图生命周期：创建、存在、销毁</h3><ul><li>创建一个地图</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> AMap.Map(<span class="hljs-string">'container'</span>); <span class="hljs-comment">//container为地图容器的id</span></code></pre><ul><li>创建时添加其他样式</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> AMap.Map(<span class="hljs-string">'container'</span>, &#123;        zoom:<span class="hljs-number">11</span>,<span class="hljs-comment">//级别</span>        zooms: [<span class="hljs-number">4</span>,<span class="hljs-number">18</span>],<span class="hljs-comment">//设置地图级别范围</span>        center: [<span class="hljs-number">116.397428</span>, <span class="hljs-number">39.90923</span>],<span class="hljs-comment">//中心点坐标</span>        viewMode:<span class="hljs-string">'3D'</span>,<span class="hljs-comment">//使用3D视图</span>        mapStyle: <span class="hljs-string">'amap://styles/whitesmoke'</span>,  <span class="hljs-comment">//设置地图的显示样式</span>    layers: [<span class="hljs-comment">//使用多个图层</span>            <span class="hljs-keyword">new</span> AMap.TileLayer.Satellite(),            <span class="hljs-keyword">new</span> AMap.TileLayer.RoadNet()        ],    lang:<span class="hljs-string">'zh_cn'</span> <span class="hljs-comment">//设置地图语言类型</span>&#125;);</code></pre><ul><li><p>地图加载完成后触发complete</p><pre><code class="hljs javascript">map.on(<span class="hljs-string">'complete'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// 地图图块加载完成后触发</span>&#125;);</code></pre></li><li><p>销毁地图对象</p><pre><code class="hljs javascript"><span class="hljs-comment">// 销毁地图，并清空地图容器</span>map.destroy( );</code></pre></li><li><p>获取设置地图状态</p><pre><code class="hljs javascript"><span class="hljs-comment">//中心点</span><span class="hljs-keyword">var</span> position = <span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">116</span>, <span class="hljs-number">39</span>);map.setCenter(position); <span class="hljs-comment">//设置中心点</span><span class="hljs-keyword">var</span> currentCenter = map.getCenter(); <span class="hljs-comment">//获取当前中心点</span><span class="hljs-comment">//地图缩放级别</span>map.setZoom(<span class="hljs-number">13</span>)map.getZoom<span class="hljs-comment">// 同时传入缩放级别和中心点经纬度</span>map.setZoomAndCenter(<span class="hljs-number">14</span>, [<span class="hljs-number">116.205467</span>, <span class="hljs-number">39.907761</span>]);<span class="hljs-comment">//地图上覆盖物较多的情况下，如果需要保证所有覆盖物都在视野范围内， 需要将地图调整到合适的缩放等级和中心点，可以调用setFitView()方法，以实现该效果。</span><span class="hljs-comment">// 无参数，默认包括所有覆盖物的情况</span>map.setFitView();<span class="hljs-comment">// 传入覆盖物数组，仅包括polyline和marker1的情况</span>map.setFitView([polyline,marker1])</code></pre><p>更多参数：<a href="http://lbs.amap.com/api/javascript-api/reference/map" target="_blank" rel="noopener">http://lbs.amap.com/api/javascript-api/reference/map</a></p></li></ul><h3 id="覆盖物"><a href="#覆盖物" class="headerlink" title="覆盖物"></a>覆盖物</h3><ul><li>点标记Marker（灵活点标记ElasticMarker、文本标记Text、原点标记CircleMarker）</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> marker = <span class="hljs-keyword">new</span> AMap.Marker(&#123;      icon: <span class="hljs-string">"http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png"</span>,  <span class="hljs-comment">//添加 Icon 图标 URL</span>      <span class="hljs-comment">//position: new AMap.LngLat(116.39, 39.9),   // 经纬度对象</span>      position:[<span class="hljs-number">116.39</span>, <span class="hljs-number">39.9</span>]  <span class="hljs-comment">//经纬度数组</span>&#125;)map.add(marker);<span class="hljs-comment">//添加到地图</span>map.remove(marker);<span class="hljs-comment">//移除点标记</span><span class="hljs-comment">//一次添加多个</span><span class="hljs-keyword">var</span> markerList = [marker1, marker2, marker3];map.add(markerList);</code></pre><ul><li><p>点标记、矢量图形、信息窗体等，均可以使用<code>add</code>方法添加 </p></li><li><p>获取覆盖物</p><pre><code class="hljs javascript"><span class="hljs-comment">//getAllOverlays(type)方法获取已经添加的覆盖物。其中type参数类型包括marker、circle、polyline、polygon，缺省是返回以上所有类型所有覆盖物</span><span class="hljs-comment">// 获取已经添加的覆盖物</span>map.getAllOverlays();<span class="hljs-comment">// 获取已经添加的marker</span>map.getAllOverlays(<span class="hljs-string">'marker'</span>);</code></pre></li><li><p>移出覆盖物</p><pre><code class="hljs javascript"><span class="hljs-comment">// 使用remove方法移除覆盖物，参数可以为单个覆盖物对象，也可以是一个包括多个覆盖物的数组</span><span class="hljs-comment">// 单独移除点标记</span>map.remove(marker);<span class="hljs-comment">// 同时移除点标记和矢量圆形</span>map.remove([marker,circle]);<span class="hljs-comment">// 使用clearMap方法删除所有覆盖物</span>map.clearMap();</code></pre></li><li><p>JS API 提供的Map、点标记、矢量图形的实例均支持事件，鼠标或者触摸操作均会触发相应的事件。通过给点标记绑定<code>click</code>事件来简单了解<a href="http://lbs.amap.com/api/javascript-api/guide/events/map_overlay" target="_blank" rel="noopener">事件系统</a>和<a href="http://lbs.amap.com/api/javascript-api/guide/overlays/infowindow" target="_blank" rel="noopener">信息窗体</a>的基本使用： </p></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> infoWindow = <span class="hljs-keyword">new</span> AMap.InfoWindow(&#123; <span class="hljs-comment">//创建信息窗体</span>    isCustom: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//使用自定义窗体</span>    content:<span class="hljs-string">'&lt;div&gt;信息窗体&lt;/div&gt;'</span>, <span class="hljs-comment">//信息窗体的内容可以是任意html片段</span>    offset: <span class="hljs-keyword">new</span> AMap.Pixel(<span class="hljs-number">16</span>, <span class="hljs-number">-45</span>)&#125;);<span class="hljs-keyword">var</span> onMarkerClick  =  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    infoWindow.open(map, e.target.getPosition());<span class="hljs-comment">//打开信息窗体</span>    <span class="hljs-comment">//e.target就是被点击的Marker</span>&#125; <span class="hljs-keyword">var</span> marker = <span class="hljs-keyword">new</span> AMap.Marker(&#123;    position: [<span class="hljs-number">116.481181</span>, <span class="hljs-number">39.989792</span>]&#125;)map.add(marker);marker.on(<span class="hljs-string">'click'</span>,onMarkerClick);<span class="hljs-comment">//绑定click事件</span></code></pre><ul><li><p>自定义Icon</p><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 AMap.Icon 实例：</span><span class="hljs-keyword">var</span> icon = <span class="hljs-keyword">new</span> AMap.Icon(&#123;    size: <span class="hljs-keyword">new</span> AMap.Size(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>),,    <span class="hljs-comment">// 图标尺寸</span>    image: <span class="hljs-string">'//webapi.amap.com/theme/v1.3/images/newpc/way_btn2.png'</span>,  <span class="hljs-comment">// Icon的图像</span>    imageOffset: <span class="hljs-keyword">new</span> AMap.Pixel(<span class="hljs-number">0</span>, <span class="hljs-number">-60</span>),  <span class="hljs-comment">// 图像相对展示区域的偏移量，适于雪碧图等</span>    imageSize: <span class="hljs-keyword">new</span> AMap.Size(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>)   <span class="hljs-comment">// 根据所设置的大小拉伸或压缩图片</span>&#125;);<span class="hljs-comment">// 将 Icon 实例添加到 marker 上:</span><span class="hljs-keyword">var</span> marker = <span class="hljs-keyword">new</span> AMap.Marker(&#123;    position: <span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">116.405467</span>, <span class="hljs-number">39.907761</span>),    offset: <span class="hljs-keyword">new</span> AMap.Pixel(<span class="hljs-number">-10</span>， <span class="hljs-number">-10</span>),    icon: icon, <span class="hljs-comment">// 添加 Icon 实例</span>    title: <span class="hljs-string">'北京'</span>,    zoom: <span class="hljs-number">13</span>&#125;);map.add(marker);<span class="hljs-comment">//向已创建好的 Marker 添加 Icon</span><span class="hljs-comment">//marker.setIcon(icon);</span></code></pre></li></ul><h3 id="信息窗体InfoWindow"><a href="#信息窗体InfoWindow" class="headerlink" title="信息窗体InfoWindow"></a>信息窗体InfoWindow</h3><ul><li>默认信息窗体</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 信息窗体的内容</span><span class="hljs-keyword">var</span> content = [    <span class="hljs-string">"&lt;div&gt;&lt;img src="</span>\<span class="hljs-string">""</span> http:=<span class="hljs-string">""</span> webapi.amap.com=<span class="hljs-string">""</span> images=<span class="hljs-string">""</span> autonavi.png=<span class="hljs-string">""</span> \<span class="hljs-string">"="</span><span class="hljs-string">"&gt; "</span>,    <span class="hljs-string">"&lt;div style="</span>\<span class="hljs-string">"padding:0px"</span> <span class="hljs-number">0</span>px=<span class="hljs-string">""</span> <span class="hljs-number">4</span>px;\<span class="hljs-string">"="</span><span class="hljs-string">"&gt;&lt;b&gt;高德软件有限公司&lt;/b&gt;"</span>,    <span class="hljs-string">"电话 : 010-84107000   邮编 : 100102"</span>,    <span class="hljs-string">"地址 : 北京市望京阜通东大街方恒国际中心A座16层&lt;/div&gt;&lt;/div&gt;"</span>];<span class="hljs-comment">// 创建 infoWindow 实例</span><span class="hljs-keyword">var</span> infoWindow = <span class="hljs-keyword">new</span> AMap.InfoWindow(&#123;   content: content.join(<span class="hljs-string">"&lt;br&gt;"</span>)  <span class="hljs-comment">//传入 dom 对象，或者 html 字符串</span>&#125;);<span class="hljs-comment">// 打开信息窗体</span>infoWindow.open(map);</code></pre><ul><li><p>自定义信息窗体</p><pre><code class="hljs javascript"><span class="hljs-comment">// 折线的节点坐标数组，每个元素为 AMap.LngLat 对象</span><span class="hljs-keyword">var</span> content = [    <span class="hljs-string">"&lt;div&gt;&lt;img src="</span>\<span class="hljs-string">""</span> http:=<span class="hljs-string">""</span> webapi.amap.com=<span class="hljs-string">""</span> images=<span class="hljs-string">""</span> autonavi.png=<span class="hljs-string">""</span> \<span class="hljs-string">"="</span><span class="hljs-string">"&gt; "</span>,    <span class="hljs-string">"&lt;div style="</span>\<span class="hljs-string">"padding:0px"</span> <span class="hljs-number">0</span>px=<span class="hljs-string">""</span> <span class="hljs-number">4</span>px;\<span class="hljs-string">"="</span><span class="hljs-string">"&gt;&lt;b&gt;高德软件有限公司&lt;/b&gt;"</span>,    <span class="hljs-string">"电话 : 010-84107000   邮编 : 100102"</span>,    <span class="hljs-string">"地址 : 北京市望京阜通东大街方恒国际中心A座16层&lt;/div&gt;&lt;/div&gt;"</span>];<span class="hljs-comment">// 实现自定义窗体内容，返回拼接后的字符串</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInfoWindow</span> (<span class="hljs-params">title, content</span>)</span>&#123;    <span class="hljs-comment">// 内容拼接 ...</span>    <span class="hljs-keyword">return</span> content;&#125;<span class="hljs-comment">// 创建 infoWindow 实例 </span><span class="hljs-keyword">var</span> infoWindow = <span class="hljs-keyword">new</span> AMap.InfoWindow(&#123;   isCustom: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//使用自定义窗体</span>   content: createInfoWindow(title,content.join(<span class="hljs-string">"&lt;br&gt;"</span>)),  <span class="hljs-comment">//传入 dom 对象，或者 html 字符串</span>   offset: <span class="hljs-keyword">new</span> AMap.Pixel(<span class="hljs-number">16</span>, <span class="hljs-number">-50</span>)<span class="hljs-comment">//偏移量 偏移量为（0,0）时自定义内容底部中心为基准点与经纬度坐标对齐</span>&#125;);</code></pre></li><li><p>信息窗体的打开与关闭</p><pre><code class="hljs javascript"><span class="hljs-comment">// 在指定位置打开已创建的信息窗体</span><span class="hljs-keyword">var</span> position = <span class="hljs-keyword">new</span> AMap.LngLat(<span class="hljs-number">116.39</span>, <span class="hljs-number">39.9</span>);infoWindow.open(map, position);<span class="hljs-comment">// 关闭信息窗体</span>infoWindow.close();</code></pre></li><li><p>信息窗体的事件</p></li><li><p>高级信息窗体AdvancedInfoWindow</p><p>封装了「输入提示、POI周边搜索、驾车路线规划、公交路线规划和步行路线规划」功能 </p><p><a href="http://lbs.amap.com/api/javascript-api/reference/infowindow#AMap.AdvancedInfoWindow" target="_blank" rel="noopener">http://lbs.amap.com/api/javascript-api/reference/infowindow#AMap.AdvancedInfoWindow</a></p></li><li><p>右键菜单ContextMenu</p></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>异步加载指的是在 JS API 加载完成之后，在需要使用到某个插件的时候，通过<code>AMap.plugin</code>方法按需引入插件，在<code>plugin</code>回调之后使用插件功能 </p><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"http://webapi.amap.com/maps?v=1.4.7&amp;key=您申请的key值"</span>&gt;&lt;<span class="hljs-regexp">/script&gt; </span><span class="hljs-regexp">&lt;script type="text/</span>javascript<span class="hljs-string">" &gt;</span><span class="hljs-string">    var map = new AMap.Map('container',&#123;</span><span class="hljs-string">        zoom:12,</span><span class="hljs-string">        center:[116.39,39.9]</span><span class="hljs-string">    &#125;);</span><span class="hljs-string">    AMap.plugin('AMap.ToolBar',function()&#123;//异步加载插件</span><span class="hljs-string">        var toolbar = new AMap.ToolBar();</span><span class="hljs-string">        map.addControl(toolbar);</span><span class="hljs-string">    &#125;);</span><span class="hljs-string">&lt;/script&gt;</span><span class="hljs-string"></span><span class="hljs-string">//异步加载多个插件</span><span class="hljs-string">AMap.plugin(['AMap.ToolBar','AMap.Driving'],function()&#123;//异步同时加载多个插件</span><span class="hljs-string">      var toolbar = new AMap.ToolBar();</span><span class="hljs-string">      map.addControl(toolbar);</span><span class="hljs-string">      var driving = new AMap.Driving();//驾车路线规划</span><span class="hljs-string">      driving.search(/*参数*/)</span><span class="hljs-string">&#125;);</span></code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li><p>Map或覆盖物对象的on、off方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> AMap.Map(<span class="hljs-string">"container"</span>);<span class="hljs-keyword">var</span> clickHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;  alert(<span class="hljs-string">'您在[ '</span>+e.lnglat.getLng()+<span class="hljs-string">','</span>+e.lnglat.getLat()+<span class="hljs-string">' ]的位置点击了地图！'</span>);&#125;;<span class="hljs-comment">// 绑定事件</span>map.on(<span class="hljs-string">'click'</span>, clickHandler);<span class="hljs-comment">// 解绑事件</span>map.off(<span class="hljs-string">'click'</span>, clickHandler);</code></pre></li><li><p>MapsEvent 对象</p><p>对于 Map、覆盖物、叠加层对象的鼠标、触屏绑定事件回调时，会返回 <code>MapsEvent</code> 对象。该对象包含触发的对象目标、触发所在经纬度等信息： </p><pre><code class="hljs javascript">map.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) </span>&#123;  <span class="hljs-comment">// 触发事件的对象</span>  <span class="hljs-keyword">var</span> target = ev.target;    <span class="hljs-comment">// 触发事件的地理坐标，AMap.LngLat 类型</span>  <span class="hljs-keyword">var</span> lnglat = ev.lnglat;    <span class="hljs-comment">// 触发事件的像素坐标，AMap.Pixel 类型</span>  <span class="hljs-keyword">var</span> pixel = ev.pixel;    <span class="hljs-comment">// 触发事件类型</span>  <span class="hljs-keyword">var</span> type = ev.type;&#125;);</code></pre></li><li><p>地图事件</p><pre><code class="hljs javascript">地图加载完成  complete地图缩放等级改变  zoomstart、zoomend地图中心点移动  mapmove、movestart、moveend地图容器尺寸改变  resize鼠标按下及移动等      click、                    dblclick、                    mousemove、                    mouseover、                    mouseout、                    mouseup、                    mousedown、                    mousewheel、                    rightclick                    触屏点击touchstart、touchmove、touchend</code></pre></li><li><p>覆盖物事件</p><pre><code class="hljs autoit">Marker、Text 类对象发生移动   moving、moveend、movealong矢量图形显示、隐藏hide、showContextMenu 类对象打开关闭open、close鼠标按下及移动等 click、                    dblclick、                    <span class="hljs-built_in">mousemove</span>、                    mouseover、                    mouseout、                    <span class="hljs-built_in">mouseup</span>、                    <span class="hljs-built_in">mousedown</span>、                    <span class="hljs-built_in">mousewheel</span>、                    rightclick触屏点击touchstart、 touchmove、 touchend</code></pre></li></ul><p><a href="http://lbs.amap.com/api/javascript-api/guide/events/map_overlay" target="_blank" rel="noopener">http://lbs.amap.com/api/javascript-api/guide/events/map_overlay</a></p><h3 id="DOM事件，自定义事件"><a href="#DOM事件，自定义事件" class="headerlink" title="DOM事件，自定义事件"></a>DOM事件，自定义事件</h3><h3 id="输入提示与POI搜索"><a href="#输入提示与POI搜索" class="headerlink" title="输入提示与POI搜索"></a>输入提示与POI搜索</h3><ul><li>输入提示插件 <code>AMap.Autocomplete</code></li><li>POI搜索插件<code>AMap.PlaceSearch</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>GIS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie/登录注册</title>
    <link href="/2018/06/09/cookie-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"/>
    <url>/2018/06/09/cookie-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>Cookie：</p><ol><li>服务器通过Set-Cookie头给客户端一串字符串</li><li>客户端每次访问相同域名的网页时，必须带上这段字符串</li><li>客户端要在一段时间内保存这个Cookie</li><li>在用户关闭页面后就失效，后台代码可以任意设置Cookie的过期时间</li><li>大小4k左右</li></ol><a id="more"></a><p>Session ：   依赖Cookie</p><ol><li>将SessionID通过Cookie发给客户端</li><li>客户端访问服务器时，服务器读取SessionID</li><li>服务器有一块内存（哈希表）保存了所有的session</li><li>通过SessionID我们可以得到对应用户的隐私信息，如id、email</li><li>这块内存（哈希表）就是服务器上的所有session</li></ol><p>*不基于Cookie的Session</p><p>LocalStorage：</p><ol><li>LocalStorage跟HTTP无关</li><li>HTTP不会带上LocalStorage的值</li><li>只有相同域名的页面才能相互读取LocalStorage（没有同源那么严格）</li><li>每个域名LocalStorage最大存储量为5MB左右（每个浏览器不一样）</li><li>常用场景：记录有没有提示过用户。。。（不重要的信息，不能记录密码）</li><li>LocalStorage永久有效，除非用户清理缓存</li></ol><p>SessionStorage</p><p>1234同上</p><ol start="5"><li>SessionStorage在用户关闭页面（会话结束）后就失效</li></ol><p>Cache-Control 设置时间长度</p><p>Expires 过时    设置指定时间过期</p><p>MD5 讯息摘要算法</p><p>ETag</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>javaScript基础</title>
    <link href="/2018/06/08/javaScript%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/06/08/javaScript%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>六种</p><ul><li>数值（number）</li><li>字符串（string）</li><li>布尔值（boolean）</li><li>undefined</li><li>null</li><li>对象（object）</li></ul><a id="more"></a><pre><code class="hljs javascript"><span class="hljs-comment">//typeof返回一个值的数据类型</span><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span> <span class="hljs-comment">//"number"</span><span class="hljs-keyword">typeof</span> <span class="hljs-string">'123'</span> <span class="hljs-comment">// "string"</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// "boolean"</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">typeof</span> f<span class="hljs-comment">// "function"</span><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> <span class="hljs-comment">// "object"</span><span class="hljs-keyword">typeof</span> &#123;&#125; <span class="hljs-comment">// "object"</span><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// "object"</span></code></pre><hr><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)<span class="hljs-comment">//0</span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)<span class="hljs-comment">//NaN</span></code></pre><p>布尔值为false的几种值</p><ul><li>undefined</li><li>null</li><li>false</li><li>0</li><li>NaN</li><li>“”或’’(空字符串)</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">//Infinity 无穷</span><span class="hljs-number">-1</span>/<span class="hljs-number">-0</span> <span class="hljs-comment">//Infinity</span><span class="hljs-number">1</span>/<span class="hljs-number">-0</span> <span class="hljs-comment">//-Infinity</span><span class="hljs-comment">//数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错</span><span class="hljs-comment">//Infinity与NaN比较，总是返回false。</span></code></pre><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'1000'</span>) <span class="hljs-comment">// 1000</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'1000'</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 1000</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'1000'</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 8 二进制</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'1000'</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 512 八进制</span><span class="hljs-comment">//字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'0x10'</span>) <span class="hljs-comment">// 16</span><span class="hljs-built_in">parseFloat</span><span class="hljs-comment">//浮点数</span><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//false 判断是否是NaN</span><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">//true 判断是否是正常数值</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//对象 </span><span class="hljs-keyword">var</span> obj = &#123;    <span class="hljs-comment">//键值对：key：value</span>  foo: <span class="hljs-string">'Hello'</span>, bar: <span class="hljs-string">'World'</span>&#125;<span class="hljs-comment">// 或</span><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-string">'foo'</span>: <span class="hljs-string">'Hello'</span>,  <span class="hljs-string">'bar'</span>: <span class="hljs-string">'World'</span>&#125;;<span class="hljs-comment">//键名为数值会自动转换为字符串</span><span class="hljs-comment">//键名又称为属性（property）</span><span class="hljs-comment">//属性的值为函数</span><span class="hljs-keyword">var</span> obj = &#123;  p: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;  &#125;&#125;;obj.p(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 链式引用，属性的值是对象</span><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<span class="hljs-keyword">var</span> o2 = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-string">'hello'</span> &#125;;o1.foo = o2;o1.foo.bar <span class="hljs-comment">// "hello"</span><span class="hljs-keyword">var</span> obj = &#123;  p: <span class="hljs-string">'Hello World'</span>&#125;;<span class="hljs-comment">//两种读取方法</span>obj.p <span class="hljs-comment">// "Hello World"</span>obj[<span class="hljs-string">'p'</span>] <span class="hljs-comment">// "Hello World"</span><span class="hljs-keyword">var</span> obj = &#123;  key1: <span class="hljs-number">1</span>,  key2: <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 属性查看</span><span class="hljs-built_in">Object</span>.keys(obj);<span class="hljs-comment">// ['key1', 'key2']</span><span class="hljs-comment">// 属性删除</span><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// ["p"]</span><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// true</span>obj.p <span class="hljs-comment">// undefined</span><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// []</span><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-string">'p'</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true，继承属性</span><span class="hljs-keyword">var</span> obj = &#123;&#125;;<span class="hljs-keyword">if</span> (<span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> obj) &#123;  <span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">'toString'</span>)) <span class="hljs-comment">// false</span>&#125;<span class="hljs-comment">//for...in循环遍历对象的属性</span><span class="hljs-comment">//遍历所有可遍历的属性，包括继承的属性</span><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'键名：'</span>, i);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'键值：'</span>, obj[i]);&#125;<span class="hljs-comment">// 键名： a</span><span class="hljs-comment">// 键值： 1</span><span class="hljs-comment">// 键名： b</span><span class="hljs-comment">// 键值： 2</span><span class="hljs-comment">// 键名： c</span><span class="hljs-comment">// 键值： 3</span><span class="hljs-comment">// with语句</span><span class="hljs-comment">// 例一</span><span class="hljs-keyword">var</span> obj = &#123;  p1: <span class="hljs-number">1</span>,  p2: <span class="hljs-number">2</span>,&#125;;<span class="hljs-keyword">with</span> (obj) &#123;  p1 = <span class="hljs-number">4</span>;  p2 = <span class="hljs-number">5</span>;&#125;<span class="hljs-comment">// 等同于</span>obj.p1 = <span class="hljs-number">4</span>;obj.p2 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 例二</span><span class="hljs-keyword">with</span> (<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>])&#123;  <span class="hljs-built_in">console</span>.log(href);  <span class="hljs-built_in">console</span>.log(title);  <span class="hljs-built_in">console</span>.log(style);&#125;<span class="hljs-comment">// 等同于</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].href);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].title);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].style);</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 函数声明，3种</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(s);&#125;<span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(s);&#125;;<span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">//函数名x只在函数体内部有效</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);&#125;;<span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(  <span class="hljs-string">'x'</span>,  <span class="hljs-string">'y'</span>,  <span class="hljs-string">'return x + y'</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-comment">//函数多次声明会被覆盖</span><span class="hljs-comment">//name属性返回函数名</span><span class="hljs-keyword">var</span> myFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">f</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(f.name);&#125;test(myFunc) <span class="hljs-comment">// myFunc</span><span class="hljs-comment">//length 返回函数预期传入的参数个数</span><span class="hljs-comment">//JavaScript 允许省略参数。</span><span class="hljs-comment">//arguments对象包含了函数运行时的所有参数</span><span class="hljs-comment">//arguments对象带有一个callee属性，返回它所对应的原函数。</span><span class="hljs-comment">//toString方法返回一个字符串，内容是函数的源码。</span><span class="hljs-comment">//闭包（closure）</span><span class="hljs-comment">//定义在一个函数内部的函数</span><span class="hljs-comment">//作用：一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在;封装对象的私有属性和私有方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIncrementor</span>(<span class="hljs-params">start</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> start++;  &#125;;&#125;<span class="hljs-keyword">var</span> inc = createIncrementor(<span class="hljs-number">5</span>);inc() <span class="hljs-comment">// 5</span>inc() <span class="hljs-comment">// 6</span>inc() <span class="hljs-comment">// 7</span><span class="hljs-comment">//eval命令接受一个字符串作为参数，并将这个字符串当作语句执行</span><span class="hljs-built_in">eval</span>(<span class="hljs-string">'var a = 1;'</span>);a <span class="hljs-comment">// 1</span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种特殊的对象</p><pre><code class="hljs javascript"><span class="hljs-comment">//length</span><span class="hljs-comment">//in 键名是否存在</span><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> ];<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> arr  <span class="hljs-comment">// true</span><span class="hljs-string">'2'</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// true</span><span class="hljs-number">4</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// false</span><span class="hljs-comment">// for in</span><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;  <span class="hljs-built_in">console</span>.log(a[i]);&#125;<span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-comment">// for循环</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;  <span class="hljs-built_in">console</span>.log(a[i]);&#125;<span class="hljs-comment">// while循环</span><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (i &lt; a.length) &#123;  <span class="hljs-built_in">console</span>.log(a[i]);  i++;&#125;<span class="hljs-keyword">var</span> l = a.length;<span class="hljs-keyword">while</span> (l--) &#123;  <span class="hljs-built_in">console</span>.log(a[l]);&#125;<span class="hljs-comment">//forEach</span><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>];colors.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(color);&#125;);<span class="hljs-comment">// red</span><span class="hljs-comment">// green</span><span class="hljs-comment">// blue</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承与原型链</title>
    <link href="/2018/06/07/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2018/06/07/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>)</span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;     <span class="hljs-keyword">this</span>.talk = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-string">"Hello!"</span>);    &#125;&#125;<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Tom'</span>, <span class="hljs-number">13</span>);<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Lucy'</span>, <span class="hljs-number">18</span>);</code></pre><p>person1和person2是Person的实例，这两个实例都有一个construct属性，该属性指向Person</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(person1.contructor == Person); <span class="hljs-comment">//true</span></code></pre><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>JavaScript对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或是到达原型链的末尾。</p><p>每个函数对象都有一个prototype属性，这个属性指向函数的原型对象</p><pre><code class="hljs elm">每个对象都有__proto__属性，但只有函数对象才有proto<span class="hljs-keyword">type</span>属性</code></pre><p>原型对象会自动获得一个constructor属性，这个属性指向prototype属性所在的函数</p><pre><code class="hljs javascript">Person.prototype.constructor == Person</code></pre><p>如果对Person.prototype赋值，那么这个constructor属性就没了，可以自己给constructor重新赋值</p><pre><code class="hljs javascript">Person.prototype = &#123;    <span class="hljs-keyword">constructor</span>: Person,    walk: function()&#123;...&#125;&#125;</code></pre><p><code>__proto__</code> </p><pre><code class="hljs javascript">person1.__proto__ == Person.prototype</code></pre><p>所有<em>函数对象</em>的<code>__proto__</code> 都指向Function.prototype，它是一个空函数（Empty function）</p><p>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器<code>Object</code>及<code>Function</code>自身。所有构造器都继承了·Function.prototype·的属性及方法 </p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype</code></pre><pre><code class="hljs reasonml">var object = &#123;&#125;object.__proto__<span class="hljs-operator"> ===  </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype  <span class="hljs-comment">// 为 true</span>var fn = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;fn.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype  <span class="hljs-comment">// 为 true</span>fn.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span>var <span class="hljs-built_in">array</span> = <span class="hljs-literal">[]</span><span class="hljs-built_in">array</span>.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span><span class="hljs-built_in">array</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span><span class="hljs-literal">true</span>.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Boolean</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype <span class="hljs-comment">// 为 true</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSONP</title>
    <link href="/2018/05/27/JSONP/"/>
    <url>/2018/05/27/JSONP/</url>
    
    <content type="html"><![CDATA[<h3 id="浏览器同源政策"><a href="#浏览器同源政策" class="headerlink" title="浏览器同源政策"></a>浏览器同源政策</h3><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><ul><li>用图片创造get请求</li></ul><pre><code class="hljs javascript">button.addEventListener(<span class="hljs-string">'click'</span>, (e)=&gt;&#123;    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)    image.src = <span class="hljs-string">'/pay'</span>    image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 状态码是 200~299 则表示成功</span>        alert(<span class="hljs-string">'成功'</span>)    &#125;    image.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 状态码大于等于 400 则表示失败</span>        alert(<span class="hljs-string">'失败'</span>)    &#125;&#125;)</code></pre><a id="more"></a><ul><li>用script创造get请求</li></ul><pre><code class="hljs javascript">button.addEventListener(<span class="hljs-string">'click'</span>, (e)=&gt;&#123;    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>)    script.src = <span class="hljs-string">'/pay'</span>    <span class="hljs-built_in">document</span>.body.appendChild(script)    script.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <span class="hljs-comment">// 状态码是 200~299 则表示成功</span>        e.currentTarget.remove()    &#125;    script.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <span class="hljs-comment">// 状态码大于等于 400 则表示失败</span>        e.currentTarget.remove()    &#125;&#125;)<span class="hljs-comment">//后端代码</span>...<span class="hljs-keyword">if</span> (path === <span class="hljs-string">'/pay'</span>)&#123;    <span class="hljs-keyword">let</span> amount = fs.readFileSync(<span class="hljs-string">'./db'</span>, <span class="hljs-string">'utf8'</span>)    amount -= <span class="hljs-number">1</span>    fs.writeFileSync(<span class="hljs-string">'./db'</span>, amount)    response.setHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/javascript'</span>)    response.write(<span class="hljs-string">'amount.innerText = '</span> + amount)    response.end()&#125;...<span class="hljs-comment">//SRJ - Server Rendered JavaScript</span></code></pre><ul><li>JSONP</li></ul><pre><code class="hljs javascript">button.addEventListener(<span class="hljs-string">'click'</span>, (e)=&gt;&#123;    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>)    <span class="hljs-keyword">let</span> functionName = <span class="hljs-string">'frank'</span>+ <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10000000</span> ,<span class="hljs-number">10</span>)    <span class="hljs-built_in">window</span>[functionName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// 每次请求之前搞出一个随机的函数</span>        amount.innerText = amount.innerText - <span class="hljs-number">0</span> - <span class="hljs-number">1</span>    &#125;    script.src = <span class="hljs-string">'/pay?callback='</span> + functionName    <span class="hljs-built_in">document</span>.body.appendChild(script)    script.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <span class="hljs-comment">// 状态码是 200~299 则表示成功</span>        e.currentTarget.remove()        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">window</span>[functionName] <span class="hljs-comment">// 请求完了就干掉这个随机函数</span>    &#125;    script.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <span class="hljs-comment">// 状态码大于等于 400 则表示失败</span>        e.currentTarget.remove()        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">window</span>[functionName] <span class="hljs-comment">// 请求完了就干掉这个随机函数</span>    &#125;&#125;)<span class="hljs-comment">//后端代码</span>...<span class="hljs-keyword">if</span> (path === <span class="hljs-string">'/pay'</span>)&#123;    <span class="hljs-keyword">let</span> amount = fs.readFileSync(<span class="hljs-string">'./db'</span>, <span class="hljs-string">'utf8'</span>)    amount -= <span class="hljs-number">1</span>    fs.writeFileSync(<span class="hljs-string">'./db'</span>, amount)    <span class="hljs-keyword">let</span> callbackName = query.callback    response.setHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/javascript'</span>)    response.write(<span class="hljs-string">`</span><span class="hljs-string">        <span class="hljs-subst">$&#123;callbackName&#125;</span>.call(undefined, 'success')</span><span class="hljs-string">    `</span>)    response.end()&#125;...</code></pre><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><ul><li><p>请求方：frank.com 的前端程序员（浏览器）<br>响应方：jack.com 的后端程序员（服务器）</p><ol><li>请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy</li><li>响应方根据查询参数callbackName，构造形如<ol><li>yyy.call(undefined, ‘你要的数据’)</li><li>yyy(‘你要的数据’)<br>这样的响应</li></ol></li><li>浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’)</li><li>那么请求方就知道了他要的数据</li></ol><p>这就是 JSONP</p></li><li><p>约定</p><ol><li>callbackName -&gt; callback</li><li>yyy -&gt; 随机数 frank12312312312321325()</li></ol><pre><code class="hljs javascript">$.ajax(&#123; url: <span class="hljs-string">"http://jack.com:8002/pay"</span>, dataType: <span class="hljs-string">"jsonp"</span>, success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> response </span>) </span>&#123;     <span class="hljs-keyword">if</span>(response === <span class="hljs-string">'success'</span>)&#123;     amount.innerText = amount.innerText - <span class="hljs-number">1</span>     &#125; &#125; &#125;)<span class="hljs-comment">//ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</span></code></pre></li><li><p>JSONP和JSON、AJAX没有关系</p></li><li><p>JSONP为什么不支持POST？</p><p>因为JSONP是通过动态创建Script实现的，而动态创建Script只能使用GET，不能使用POST</p><p>​</p></li></ul><p><a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery</title>
    <link href="/2018/05/05/jQuery/"/>
    <url>/2018/05/05/jQuery/</url>
    
    <content type="html"><![CDATA[<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> dom = &#123;&#125;dom.getSiblings(node)dom.addClass(node, &#123;<span class="hljs-attr">a</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">b</span>:<span class="hljs-literal">false</span>&#125;)</code></pre><a id="more"></a><h4 id="获取兄弟结点的方法"><a href="#获取兄弟结点的方法" class="headerlink" title="获取兄弟结点的方法"></a>获取兄弟结点的方法</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSiblings</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">var</span> allChildren = node.parentNode.children        <span class="hljs-keyword">var</span> array = &#123;        length: <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; allChildren.length; i++)&#123;        <span class="hljs-keyword">if</span>(allChildren[i] !== node)&#123;            array[array.length] = allChildren[i]            array.length += <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> array&#125;</code></pre><h4 id="添加类的方法"><a href="#添加类的方法" class="headerlink" title="添加类的方法"></a>添加类的方法</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClass</span>(<span class="hljs-params">node, classes</span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> classes)&#123;        <span class="hljs-keyword">var</span> value = classes[key]        <span class="hljs-keyword">if</span>(value) &#123;            node.classList.add(key)        &#125; <span class="hljs-keyword">else</span> &#123;            node.classList.remove(key)        &#125;        <span class="hljs-comment">/*if else可改写为</span><span class="hljs-comment">        var methodName = value ? 'add':'remove'</span><span class="hljs-comment">        node.classList[methodName](key)</span><span class="hljs-comment">        */</span>    &#125;&#125;addClass(item3, &#123;<span class="hljs-attr">a</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">b</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">c</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//添加为true的类，删除为false的类</span></code></pre><h4 id="将node放在前面的方法"><a href="#将node放在前面的方法" class="headerlink" title="将node放在前面的方法"></a>将node放在前面的方法</h4><ul><li><p>拓展Node接口</p><p>直接在Node.prototype上添加函数</p></li><li><p>新的接口BetterNode</p><pre><code class="hljs javascript"><span class="hljs-comment">//无侵入</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node2</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">return</span> &#123;        element: node,        getSiblings:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                    &#125;,        addClass:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                    &#125;    &#125;&#125;<span class="hljs-keyword">let</span> node = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'x'</span>)<span class="hljs-keyword">let</span> node2 = Node2(node)node2.getSiblings()node2.addClass()</code></pre></li></ul><h4 id="给-Node2-改个名字"><a href="#给-Node2-改个名字" class="headerlink" title="给 Node2 改个名字"></a>给 Node2 改个名字</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jQuery</span>(<span class="hljs-params">nodeOrSelector</span>)</span>&#123;    <span class="hljs-keyword">let</span> node    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> nodeOrSelector === <span class="hljs-string">'string'</span>)&#123;        node = <span class="hljs-built_in">document</span>.querySelector(nodeOrSelector)    &#125; <span class="hljs-keyword">else</span>&#123;        node = nodeOrSelector    &#125;        <span class="hljs-keyword">return</span> &#123;        getSiblings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">var</span> allChildren = node.parentNode.children                        <span class="hljs-keyword">var</span> array = &#123;                length: <span class="hljs-number">0</span>            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; allChildren.length; i++) &#123;                <span class="hljs-keyword">if</span>(allChildren[i] !== node) &#123;                    array[array.length] = allChildren[i]                    array.length += <span class="hljs-number">1</span>                &#125;            &#125;            <span class="hljs-keyword">return</span> array        &#125;,        addClass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">classes</span>) </span>&#123;            classes.forEach( <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> node.classList.add(value) )        &#125;    &#125;&#125;</code></pre><h4 id="再给个缩写"><a href="#再给个缩写" class="headerlink" title="再给个缩写"></a>再给个缩写</h4><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.$ = jQuery</code></pre><h4 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a>多个节点</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jQuery</span>(<span class="hljs-params">nodeOrSelector</span>)</span>&#123;    <span class="hljs-keyword">let</span> nodes = &#123;&#125;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> nodeOrSelector === <span class="hljs-string">'string'</span>)&#123;    <span class="hljs-keyword">let</span> temp = <span class="hljs-built_in">document</span>.querySelectorAll(nodeOrSelector) <span class="hljs-comment">//伪数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; temp.length; i++)&#123;            nodes[i] = temp[i]        &#125;        nodes.length = temp.length    &#125; <span class="hljs-keyword">else</span>&#123;        nodes = &#123;            <span class="hljs-number">0</span>: nodeOrSelector,            length: <span class="hljs-number">1</span>        &#125;    &#125;          nodes.getSiblings = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    &#125;   nodes.addClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">classes</span>) </span>&#123;        classes.forEach(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodes.length; i++)&#123;                nodes[i].classList.add(value)            &#125;        &#125;)    &#125;    nodes.getText = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> texts = []        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodes.length; i++)&#123;            texts.push(nodes[i].textContent)        &#125;        <span class="hljs-keyword">return</span> texts    &#125;    nodes.setText = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>)</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodes.lenth; i++)&#123;            nodes[i].textContent = text        &#125;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    nodes.text = functionn(text) &#123;</span><span class="hljs-comment">        if(text === undefined) &#123;</span><span class="hljs-comment">            var texts = []</span><span class="hljs-comment">            for(let i = 0; i &lt; nodes.length; i++) &#123;</span><span class="hljs-comment">                texts.push(nodes[i].textContent)</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">            return texts</span><span class="hljs-comment">        &#125; else &#123;</span><span class="hljs-comment">            for(let i = 0; i &lt; nodes.length; i++) &#123;</span><span class="hljs-comment">                nodes[i].textContent = text</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">return</span> nodes&#125;<span class="hljs-keyword">var</span> node2 = jQuery(<span class="hljs-string">'ul &gt; li'</span>)node2.addClass([<span class="hljs-string">'blue'</span>])</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用和指针</title>
    <link href="/2018/04/05/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/"/>
    <url>/2018/04/05/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="引用（reference"><a href="#引用（reference" class="headerlink" title="引用（reference)"></a>引用（reference)</h3><ul><li><p>引用为对象起了另一个名字</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<span class="hljs-keyword">int</span> &amp;refVal = ival;  <span class="hljs-comment">//refVal指向ival，是ival的另一个名字</span><span class="hljs-keyword">int</span>&amp; refVal2 = ival；</code></pre></li></ul><a id="more"></a><ul><li><p>引用必须被初始化，不存在空引用，无法令引用重新绑定到另外一个对象</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;refVal; <span class="hljs-comment">//报错，引用没有初始化</span></code></pre></li><li><p>定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的</p><pre><code class="hljs c++">refVal = <span class="hljs-number">2</span>; <span class="hljs-comment">//将2赋给了refVal指向的对象</span><span class="hljs-keyword">int</span> &amp;refVal3 = refVal; <span class="hljs-comment">//将refVal3绑定到refVal绑定的对象上</span></code></pre></li><li><p>引用本身不是一个对象，所以不能定义引用的引用</p></li><li><p>引用的类型要和与之绑定的对象严格匹配，引用类型的初始值必须是一个对象</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> &amp;refVal4 = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误：引用类型的初始值必须是一个对象</span><span class="hljs-keyword">double</span> a = <span class="hljs-number">3.14</span>；<span class="hljs-keyword">int</span> &amp;refVal5 = a; <span class="hljs-comment">//错误：类型不匹配</span></code></pre><p>两个例外</p><pre><code class="hljs c++"><span class="hljs-comment">//1.在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>;  <span class="hljs-comment">//正确：r2为一个常量引用</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>;  <span class="hljs-comment">//正确：r3为一个常量引用</span><span class="hljs-comment">//2.存在继承关系的类,可以将基类的指针或引用绑定到派生类对象上。</span></code></pre></li></ul><h3 id="指针（pointer）"><a href="#指针（pointer）" class="headerlink" title="指针（pointer）"></a>指针（pointer）</h3><ul><li><p>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</p></li><li><p>指针无需在定义时赋值，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *ip1; <span class="hljs-comment">//ip1是指向int型对象的指针</span><span class="hljs-keyword">int</span>* ip2; <span class="hljs-comment">//合法但容易产生误解</span><span class="hljs-keyword">int</span>* a,b; <span class="hljs-comment">//a为指向int的指针，b为int型变量</span></code></pre></li><li><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p = &amp;ival; <span class="hljs-comment">//p存放变量ival的地址，或者说p是指向变量ival的指针</span></code></pre></li><li><p>除两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配</p></li><li><p>如果指针指向一个对象，则允许使用解引用符（*）来访问该对象</p><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; *p;  <span class="hljs-comment">//输出42</span>*p = <span class="hljs-number">0</span>;  <span class="hljs-comment">//为*p赋值实际上是为p所指的对象赋值</span><span class="hljs-built_in">cout</span> &lt;&lt; *p; <span class="hljs-comment">//输出0</span></code></pre></li><li><p>空指针（null pointer）</p><p>不指向任何对象</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//等价于int *p1 = 0;</span></code></pre></li><li><p>void*指针</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span> *pv = &amp;obj; <span class="hljs-comment">//obj可以是任意类型的对象</span></code></pre></li><li><p>指向指针的指针</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<span class="hljs-keyword">int</span> *pi = &amp;ival;   <span class="hljs-comment">//pi指向一个int型的数</span><span class="hljs-keyword">int</span> **ppi = &amp;pi;  <span class="hljs-comment">//ppi指向一个int型的指针</span></code></pre></li><li><p>指向指针的引用</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p;<span class="hljs-keyword">int</span> *&amp;r = p; <span class="hljs-comment">//r是一个对指针p的引用</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外部排序</title>
    <link href="/2018/04/03/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    <url>/2018/04/03/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ul><li>外部排序指大文件的排序，即待排序的记录存储在外存储器上，在排序过程中需要进行多次的内、外存之间的交换。</li></ul><h3 id="外存信息的存取"><a href="#外存信息的存取" class="headerlink" title="外存信息的存取"></a>外存信息的存取</h3><a id="more"></a><h5 id="磁带信息的存取"><a href="#磁带信息的存取" class="headerlink" title="磁带信息的存取"></a>磁带信息的存取</h5><h5 id="磁盘信息的存取"><a href="#磁盘信息的存取" class="headerlink" title="磁盘信息的存取"></a>磁盘信息的存取</h5><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h4 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h4><h4 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h4><h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/2018/04/02/%E6%9F%A5%E6%89%BE/"/>
    <url>/2018/04/02/%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="查找表（Search-Table）"><a href="#查找表（Search-Table）" class="headerlink" title="查找表（Search Table）"></a>查找表（Search Table）</h3><ul><li>查找表是由同一类型的数据元素（或记录）构成的集合</li></ul><ul><li>对查找表进行的操作有：<ul><li>查询某个元素是否在表中</li><li>检索某个元素的各种属性</li><li>在查找表中插入一个数据元素</li><li>在查找表中删除某个数据元素</li></ul></li></ul><a id="more"></a><ul><li>若对查找表只做前两种统称为查找的操作，则称为静态查找表（Static Search Table）,若还进行插入或删除操作，称其为动态查找表（Dynamic Search Table）</li><li>关键字（Key）：是数据元素中某个数据项的值，可以标识一个数据元素</li><li>主关键字（Primary Key）：此关键字可以唯一地标识一个记录</li><li>次关键字（Secondary Key）：用以标识若干记录的关键字</li><li>平均查找长度（Average Search Length - ALS）：需和给定值进行比较的关键字的个数的期望值</li></ul><h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><h5 id="顺序查找（Sequential-Search）"><a href="#顺序查找（Sequential-Search）" class="headerlink" title="顺序查找（Sequential Search）"></a>顺序查找（Sequential Search）</h5><ul><li>逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值相等，则查找成功</li><li>平均查找长度较大，当n很大时，查找效率低</li><li>算法简单且适用面广</li></ul><h5 id="折半查找（Binary-Search）"><a href="#折半查找（Binary-Search）" class="headerlink" title="折半查找（Binary Search）"></a>折半查找（Binary Search）</h5><ul><li>有序表，且限于顺序存储结构，对线性链表无法有效进行折半查找</li><li>先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止</li><li>类似还有斐波那契查找和插值查找</li></ul><h5 id="静态树表的查找"><a href="#静态树表的查找" class="headerlink" title="*静态树表的查找"></a>*静态树表的查找</h5><h5 id="索引顺序查找"><a href="#索引顺序查找" class="headerlink" title="索引顺序查找"></a>索引顺序查找</h5><ul><li>又称分块查找</li><li>需建立一个索引表</li><li>将表分为多个子表，每个子表建立一个索引项，其中包含：<ul><li>关键字项：其值为该子表内最大关键字</li><li>指针项：指示该子表的第一个记录在表中的位置</li></ul></li><li>索引表按关键字有序，表有序或分块有序</li><li>查找过程：先根据索引表确定待查记录所在的块（子表），然后在块中顺序查找（块内有序可用折半查找）</li></ul><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><ul><li>特点：表结构本身是在查找过程中动态生成的，即对于给顶值key，若表中存在，则返回查找结果，若不存在，则插入关键字等于key的记录</li></ul><h5 id="二叉排序树（Binary-Sort-Tree）"><a href="#二叉排序树（Binary-Sort-Tree）" class="headerlink" title="二叉排序树（Binary Sort Tree）"></a>二叉排序树（Binary Sort Tree）</h5><ul><li>二叉排序树若不为空，则具有下列性质：<ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左右子树也分别为二叉排序树。</li></ul></li><li>又称二叉查找树</li><li>查找：<ul><li>先查找其根节点，如果根节点的数据与key值相等，则返回该根节点，并且返回TRUE；</li><li>否则， 如果key值大于根节点，则查询其右子树；</li><li>如果小于根节点，则查询其左子树。</li></ul></li><li>新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点</li><li>删除二叉排序树的*p结点：<ul><li>若*p结点为叶子结点，即P<sub>L</sub>和P<sub>R</sub>均为空树。由于删除叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可</li><li>若*p结点只有左子树P<sub>L</sub>或只有右子树P<sub>R</sub>，此时只要令P<sub>L</sub>或P<sub>R</sub>直接成为其双亲结点的左子树即可。</li><li>若*p结点的左子树和右子树均不空。为保持其他元素的相对不变，可以有两种做法：一是先直接令P<sub>L</sub>为*f的左子树，再令P<sub>R</sub>为PL子树中最右孩子的右子树。P<sub>L</sub>子树中最右孩子即为P<sub>L</sub>子树中最大的结点。二是令*p的直接前驱(或直接后继)代替*p，然后从二叉排序树中删除它的直接前驱(或直接后继)。*p的直接前驱为P<sub>L</sub>子树中最右孩子，大小仅次于*p；*p的直接后继为P<sub>R</sub>子树中最左孩子，大小仅大于*p。</li></ul></li></ul><h5 id="平衡二叉树（Balanced-Binary-Tree"><a href="#平衡二叉树（Balanced-Binary-Tree" class="headerlink" title="平衡二叉树（Balanced Binary Tree)"></a>平衡二叉树（Balanced Binary Tree)</h5><ul><li>又称AVL树</li><li>若平衡二叉树不为空，则它的左子树和右子树都是平衡二叉树，切左子树和右子树的深度之差的绝对值不超过1。</li><li>平衡因子BF（Balance Factor）定义为该结点的左子树的深度减去它的右子树的深度。</li><li>只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的</li><li>二叉排序树插入结点后失去平衡后进行调整：<ul><li>单向右旋平衡处理</li><li>单向左旋平衡处理</li><li>双向旋转（先左后右）平衡处理</li><li>双向旋转（先右后左）平衡处理</li></ul></li></ul><h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><ul><li>一种平衡的多路查找树</li><li>。。。。。。</li></ul><h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B<sup>+</sup>树</h5><ul><li>应文件系统所需而出的一种B-树的变形树</li><li>。。。。。。</li></ul><h5 id="键树"><a href="#键树" class="headerlink" title="*键树"></a>*键树</h5><ul><li>又称数字查找树（Digital Search Trees）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2018/04/01/%E6%8E%92%E5%BA%8F/"/>
    <url>/2018/04/01/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="排序（Sorting）"><a href="#排序（Sorting）" class="headerlink" title="排序（Sorting）"></a>排序（Sorting）</h3><ul><li>n个记录的序列按照对应的关键字满足的关系，成为一个按关键字有序的序列</li><li>稳定性：序列R<sub>i</sub>领先于R<sub>j</sub>，当关键字相等时，排序后的序列中R<sub>i</sub>仍领先于R<sub>j</sub>，则称排序方法是稳定的；反之，称排序算法是不稳定的</li><li>快速排序、堆排序和希尔排序等时间性能较好的排序方法是不稳定的</li></ul><a id="more"></a><ul><li>排序方法可分为内部排序和外部排序</li><li>内部排序：指待排序记录存放在计算机随机存储器中进行的排序过程</li><li>外部排序：指待排序记录的数量很大，以至内存不能一次容纳全部记录，在排序过程中尚需对外存进行访问的排序过程</li></ul><h4 id="直接插入排序（Straight-Insertion-Sort）"><a href="#直接插入排序（Straight-Insertion-Sort）" class="headerlink" title="直接插入排序（Straight Insertion Sort）"></a>直接插入排序（Straight Insertion Sort）</h4><ul><li><p>将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数值1的有序表</p></li><li><p>时间复杂度为O(n<sup>2</sup>)</p></li><li><p>若带排记录序列为正序时，时间复杂度可提高至O(n)，适合于序列基本有序的情况</p></li><li><p>空间复杂度O(1)</p><pre><code class="hljs c"><span class="hljs-comment">//从小到大</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R[],<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//待排序关键字存储在R[]</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i)    &#123;        temp=R[i];<span class="hljs-comment">//将待插入的关键字暂存于temp中</span>        j=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;temp&lt;R[j])        &#123;            R[j+<span class="hljs-number">1</span>]=R[j];<span class="hljs-comment">//大于待排关键字，后移一位</span>            --j;        &#125;        R[j+<span class="hljs-number">1</span>]=temp;<span class="hljs-comment">//找到插入位置</span>    &#125;&#125;</code></pre></li></ul><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><ul><li>基本思想与直接插入排序类似，区别是查找插入位置的方法不同，折半插入排序采用折半查找法来查找插入位置</li><li>序列已经有序</li><li>所需附加空间和直接插入排序相同，时间上比较，折半插入查找仅减少了关键字间的比较次数，记录的移动次数不变，时间复杂度为O(n<sup>2</sup>)</li></ul><h4 id="2-路插入排序"><a href="#2-路插入排序" class="headerlink" title="*2-路插入排序"></a>*2-路插入排序</h4><h4 id="希尔排序（Shell’s-Sort）"><a href="#希尔排序（Shell’s-Sort）" class="headerlink" title="希尔排序（Shell’s Sort）"></a>希尔排序（Shell’s Sort）</h4><ul><li>又称‘’缩小增量排序‘’（Diminishing Increment Sort）</li><li>基本思想：先将整个带排记录序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</li><li>子序列的构成不是简单地“逐段分割”，而是将相隔某个增量（步长）记录组成一个子序列</li><li>算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</li><li>增量序列中的值应尽量没有除1以外的公因子</li><li>时间复杂度<img src="/blogImg/shell.png" srcset="/img/loading.gif" alt=""> ？？？</li></ul><h4 id="起泡排序（Bubble-Sort）"><a href="#起泡排序（Bubble-Sort）" class="headerlink" title="起泡排序（Bubble Sort）"></a>起泡排序（Bubble Sort）</h4><ul><li><p>首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序，则将两个记录交换，然后比较第二个记录和第三个记录的关键字。依次类推，直至第n-1个记录和第n个记录的关键字进行过比较为止。这称作第一趟起泡排序</p></li><li><p>然后进行第二趟起泡排序，对前n-1个记录进行相同的操作，其结果是使关键字次大的记录被安置到第n-1个位置上，依次类推，直到结束</p></li><li><p>判别起泡排序结束的条件：在一趟起泡排序过程中没有进行交换记录的操作</p></li><li><p>时间复杂度：O(n<sup>2</sup>)</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,flag;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;--i)    &#123;        flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//标记本趟排序是否发生交换</span>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i;++j)        &#123;            <span class="hljs-keyword">if</span>(R[j<span class="hljs-number">-1</span>]&gt;R[j])            &#123;                temp=R[j];                R[j]=R[j<span class="hljs-number">-1</span>];                R[j<span class="hljs-number">-1</span>]=temp;                flag=<span class="hljs-number">1</span>;            &#125;        &#125;       <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<span class="hljs-comment">//说明序列已经有序</span>        <span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre></li></ul><h4 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h4><ul><li><p>基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序</p></li><li><p>任取一个记录作为枢轴（支点），将所有关键字比它小的记录安置在它的位置之前，所有关键字比它大的记录安置到它的位置之后，将序列分割成两个子序列。这个过程称为一趟快速排序。</p></li><li><p>在对分割所得的两个子序列进行快速排序，直至待排序列中只有一个记录。</p></li><li><p>时间复杂度：O(nlogn)；同数量级的排序方法中，其平均性能最好</p></li><li><p>空间复杂度：O(logn)，递归需要栈的辅助</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R[],<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span><span class="hljs-comment">//对从R[low]到R[high]的关键字进行排序</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">int</span> i=low,j=high;    <span class="hljs-keyword">if</span>(low&lt;high)    &#123;        temp=R[low];        <span class="hljs-keyword">while</span>(i&lt;j)<span class="hljs-comment">//一趟排序，即将数组中大于temp的关键字放在右边，小于temp的放在左边</span>        &#123;            <span class="hljs-keyword">while</span>(j&gt;i&amp;&amp;R[j]&gt;=temp)                --j;<span class="hljs-comment">//从右往左扫描，找到一个小于temp的关键字</span>            <span class="hljs-keyword">if</span>(i&lt;j)            &#123;                R[i]=R[j];<span class="hljs-comment">//放在temp左边</span>                ++i;<span class="hljs-comment">//i右移一位</span>            &#125;            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;R[i]&lt;temp)                ++i;<span class="hljs-comment">//从左往右扫描，找到一个大于temp的关键字</span>            <span class="hljs-keyword">if</span>(i&lt;j)            &#123;                R[j]=R[i];<span class="hljs-comment">//放在temp右边</span>                --j;<span class="hljs-comment">//j左移一位</span>            &#125;        &#125;        R[i]=temp;<span class="hljs-comment">//将temp放在最终位置</span>        QuickSort(R,low,i<span class="hljs-number">-1</span>);<span class="hljs-comment">//递归，对temp左边的关键字进行排序</span>        QuickSort(R,i+<span class="hljs-number">1</span>,high);<span class="hljs-comment">//递归，对temp右边的关键字进行排序</span>    &#125;&#125;</code></pre></li></ul><h4 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h4><ul><li><p>通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1&lt;=i&lt;=n）交换</p></li><li><p>时间复杂度：O(n<sup>2</sup>)</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)    &#123;        k=i;        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;n;++j)<span class="hljs-comment">//从无序序列中找到最小值</span>            <span class="hljs-keyword">if</span>(R[k]&gt;R[j])                k=j;        temp=R[i];        R[i]=R[k];        R[k]=temp;    &#125;&#125;</code></pre></li></ul><h4 id="树形选择排序（Tree-Selection-Sort）-锦标赛排序"><a href="#树形选择排序（Tree-Selection-Sort）-锦标赛排序" class="headerlink" title="*树形选择排序（Tree Selection Sort）(锦标赛排序)"></a>*树形选择排序（Tree Selection Sort）(锦标赛排序)</h4><h4 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h4><ul><li><p>将序列看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值；由此，则堆顶元素（根）必为序列中n个元素的最小值（或最大值）。</p></li><li><p>输出堆顶的最小值之后，使得剩余n-1个元素的序列重建成一个堆；反复执行，得到一个有序序列，这个过程称为堆排序</p></li><li><p>最大堆</p><p><img src="/blogImg/max-heap.png" srcset="/img/loading.gif" alt="max-heap"> </p></li><li><p>最小堆</p><p><img src="/blogImg/min-heap.png" srcset="/img/loading.gif" alt="min-heap"></p></li><li><p>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆，由无序列表建成一个堆</p></li><li><p>最大堆调整（Max-Heapify）：将堆的节点作调整，使得子节点永远小于父节点</p><p><img src="/blogImg/MAX%E2%80%90HEAPIFY-Procedure.png" srcset="/img/loading.gif" alt="Max-Heapify"> </p></li><li><p>堆排序在最坏的情况下，时间复杂度也为O(nlogn)</p></li><li><p>空间复杂度O(1)，仅需一个记录大小供交换用的辅助存储空间</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R[],<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span><span class="hljs-comment">//关键字从数组下标1开始</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i=low,j=<span class="hljs-number">2</span>*i;<span class="hljs-comment">//R[j]是R[i]的左孩子结点</span>    <span class="hljs-keyword">int</span> temp=R[i];    <span class="hljs-keyword">while</span>(j&lt;=high)    &#123;        <span class="hljs-keyword">if</span>(j&lt;high&amp;&amp;R[j]&lt;R[j+<span class="hljs-number">1</span>])<span class="hljs-comment">//若右孩子较大，则把j指向右孩子</span>            ++j;        <span class="hljs-keyword">if</span>(temp&lt;R[j])        &#123;            R[i]=R[j];<span class="hljs-comment">//将R[j]调整到双亲节点的位置</span>            i=j;            j=<span class="hljs-number">2</span>*i;        &#125;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">//调整结束</span>    &#125;    R[i]=temp;<span class="hljs-comment">//被调整的结点放入最终位置</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;--i)<span class="hljs-comment">//建立初始堆</span>        Sift(R,i,n);    <span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">2</span>;--i)<span class="hljs-comment">//进行n-1次循环，完成堆排序</span>    &#123;temp=R[<span class="hljs-number">1</span>];         R[<span class="hljs-number">1</span>]=R[i];         R[i]=temp;         Sift(R,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);    &#125;&#125;</code></pre></li></ul><h3 id="归并排序（Merging-Sort）"><a href="#归并排序（Merging-Sort）" class="headerlink" title="归并排序（Merging Sort）"></a>归并排序（Merging Sort）</h3><ul><li>“归并”：将两个或两个以上的有序表组合成一个新的有序表</li><li>假设初始序列有n个记录，看成是个有序的子序列，每个子序列长度为1，然后两两归并；得到的有序子序列再两两归并，……，直至得到一个长度为n的有序序列为止，这种排序算法称为2-路归并排序</li><li>多路归并排序</li><li>时间复杂度：O(nlogn)</li><li>需要和待排记录等数量的辅助空间</li></ul><h3 id="基数排序（Radix-Sorting）"><a href="#基数排序（Radix-Sorting）" class="headerlink" title="基数排序（Radix Sorting）"></a>基数排序（Radix Sorting）</h3><ul><li>基本思想：从最低位开始，依次进行一次稳定排序，位数不足的前面补0，直到最高一位也完成一次稳定排序。</li><li>最高位优先法（MSD法）</li><li>最低位优先法（LSD法）</li><li>链式基数排序</li><li>时间复杂度：O（d*n）</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2018/03/31/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2018/03/31/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h3><ul><li>根据键（Key）而直接访问在内存存储位置的数据结构</li><li>哈希函数(散列函数)：在记录的存储位置和它的关键词之间建立的一个确定的对应关系f，使每个关键字和结构中的一个惟一的存储位置相对应。</li></ul><a id="more"></a><ul><li>哈希表（散列表-Hash table）：在查找时，只要根据对应关系f找到给定值K的像f(K)。若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上，由此，不需要进行比较就可直接取得所查记录。按这个思想建立的表为哈希表</li><li>定义：根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映像到一个有限的连续的地址集(区间)上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表称为哈希表，这映像过程称为哈希造表或散列，所得存储位置称哈希地址或散列地址。</li><li>冲突(collision)：不同的关键字得到相同的哈希地址</li><li>同义词(synonym)：具有相同函数值的关键字</li><li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li></ul><h3 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h3><ul><li><p>直接定址法</p><p>取关键字或关键字的某个线性函数值为哈希函数。</p></li><li><p>数字分析法</p><p>假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</p></li><li><p>平方取中法</p><p>取关键字平方后的中间几位为哈希地址。</p></li><li><p>折叠法</p><p>将关键字分割成数位相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和(舍去进位)作为哈希地址。</p></li><li><p>除留余数法</p><p>取关键字被某个不大于哈希表表长m的数p出后所得余数为哈希地址。</p></li><li><p>随机数法</p><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址。当关键字长度不等时采用此法构造哈希函数较恰当。</p></li></ul><h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h3><ul><li><p>开放定址法</p><p>H<sub>i</sub> = (H(key) + d<sub>i</sub>) MOD m   i = 1,2,…,k(k&lt;=m-1)</p><ul><li>d<sub>i</sub> = 1,2,3,…,m-1，称为线性探测再散列；</li><li>d<sub>i</sub> = 1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>,…,k<sup>2</sup>,-k<sup>2</sup>,(k&lt;=m/2)称为二次探测再散列；</li><li>d<sub>i</sub> = 伪随机数序列，称伪随机探测再散列。</li></ul></li><li><p>再哈希法（再散列）</p><p>在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。</p></li><li><p>链地址法（单独链表法）</p><p>将所有关键字为同义词的记录存储在同一线性链表中。</p></li><li><p>建立一个公共溢出区</p><p>一旦发生冲突，都填入溢出表。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2018/03/29/%E5%9B%BE/"/>
    <url>/2018/03/29/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><ul><li>顶点(Vertex)：图中的数据元素</li><li>弧(Arc)：&lt;v, w&gt;表示从v到w的一条弧，v称为弧尾(Tail)或初始点，w称为弧头(Head)或终端点，此时的图称为有向图</li><li>无序对 (v, w)，表示v和w之间的一条边(Edge)，此时的图称为无向图</li></ul><a id="more"></a><ul><li>有n(n-1)/2条边的无向图称为无向完全图</li><li>有n(n-1)条弧的有向图称为有向完全图</li><li>稀疏图：有很少的边或弧，反之为稠密图</li><li>权(weight)：与图的边或弧相关的数</li><li>带权的图通常称为网(network)</li><li>子图</li><li>邻接点</li><li>顶点v的度：是和v相关联的边的数目</li><li>v的入度：以v为头的弧的数目</li><li>v的出度：以v为尾的弧的数目</li><li>路径：相邻顶点序偶所构成的序列</li><li>简单路径：顶点不重复出现的路径</li><li>回路或环(cycle)：第一个顶点和最后一个顶点相同</li><li>连通图：无向图中任意两个顶点都是连通的</li><li>连通分量：无向图中的极大连通子图</li><li>强连通图：有向图中，对于每一对顶点i和j，从i到j和从j到i都有路径</li><li>强连通分量：极大强连通子图</li></ul><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ul><li><p>邻接矩阵</p><p>图的顺序存储结构</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> no;<span class="hljs-comment">//顶点标号</span>    <span class="hljs-keyword">char</span> info;<span class="hljs-comment">//顶点其他信息，可以省略</span>&#125;VertexType;<span class="hljs-comment">//顶点类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>//图的定义</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> edges[maxSize][maxSize];    <span class="hljs-comment">//邻接矩阵定义，如果是有权图，int可改为float</span>    <span class="hljs-keyword">int</span> n,e;<span class="hljs-comment">//分别为顶点数和边数</span>    VertexType vex[maxSize];<span class="hljs-comment">//存放结点信息</span>&#125;MGraph;<span class="hljs-comment">//图的邻接矩阵类型</span></code></pre></li><li><p>邻接表</p><p>图的一种链式存储结构</p><p>对图中每个顶点建立一个单链表</p><p>第i个单链表中的结点表示依附于顶点v<sub>i</sub>的边(有向图是以顶点v<sub>i</sub>为尾的弧)</p><p>每个结点由3个域组成，其中邻接点域指示与顶点v<sub>i</sub>邻接的点在图中的位置，链域指示下一条边或弧的结点，数据域存储和边或弧相关的信息，如权值等</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> adjvex;<span class="hljs-comment">//该边所指向的结点的位置</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">nextarc</span>;</span><span class="hljs-comment">//指向下一条边的指针</span>    <span class="hljs-keyword">int</span> info;<span class="hljs-comment">//该边的相关信息，可省略</span>&#125;ArcNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> data;<span class="hljs-comment">//顶点信息</span>    ArcNode *firstarc;<span class="hljs-comment">//指向第一条边的指针</span>&#125;VNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>VNode adjlist[maxSize];<span class="hljs-comment">//邻接表</span>    <span class="hljs-keyword">int</span> n,e;<span class="hljs-comment">//顶点数和边数</span>&#125;AGraph;<span class="hljs-comment">//图的邻接表类型</span></code></pre></li><li><p>十字链表</p></li><li><p>邻接多重表</p></li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li><p>深度优先搜索（DFS）</p><p>深度优先搜索生成树</p></li><li><p>广度优先搜索（BFS）</p></li></ul><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>构造连通网的最小代价生成树</p><ul><li>普利姆(Prim)算法</li><li>克鲁斯卡尔(Kruskal)算法</li></ul><h3 id="有向无环图-directed-acycline-graph"><a href="#有向无环图-directed-acycline-graph" class="headerlink" title="有向无环图(directed acycline graph)"></a>有向无环图(directed acycline graph)</h3><ul><li>简称DAG图</li><li>拓扑排序</li><li>AOV-网：用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网(Activity On Vertex Network)</li><li>AOE-网：用边表示活动的网</li><li>关键路径</li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li><p>迪杰斯特拉(Dijkstra)算法</p><p>求图中某一顶点到其余各顶点的最短路径</p></li><li><p>弗洛伊德算法</p><p>求图中任意一对顶点间的最短路径</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2018/03/28/%E6%A0%91/"/>
    <url>/2018/03/28/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h3><ul><li>根(root)</li><li>子树</li><li>结点：树的结点包含一个数据元素及若干指向其子树的分支</li><li>结点的度(Degree)：结点拥有的子树数</li></ul><a id="more"></a><ul><li>度为0的结点称为叶子(Leaf)或终端结点</li><li>度不为0的结点称为非终端结点或分支结点</li><li>树的度是树内各结点的度的最大值</li><li>结点的子树的根称为该结点的孩子(Child)，该结点称为孩子的双亲(Parent)</li><li>同一个双亲的孩子之间互称兄弟(Sibling)</li><li>祖先，子孙，堂兄弟。。。</li><li>层次(Level)：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。。。</li><li>树的深度(Depth)或高度：树中结点的最大层次</li><li>结点的深度或高度</li><li>如果将树中结点的各子树看成从左至右是有次序的(即不能互换)，则称该树为有序树，否则为无序树</li><li>森林(Forest)：是m棵互不相交的树的集合</li></ul><h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h3><ul><li>二叉树的子树有左右之分，其次序不能任意颠倒</li><li>在二叉树的第i层上至多有2<sup>i-1</sup>个结点(i&gt;=1)</li><li>深度为k的二叉树至多有2<sup>k</sup> -1个结点(k&gt;=1)</li><li>对任何一颗二叉树T，如果其终端结点数为n<sub>0</sub> ，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</li><li>满二叉树：深度为k且有2<sup>k</sup>-1个结点的二叉树，每一层的结点数都是最大结点数</li><li>完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时。</li><li>具有n个结点的二叉树的深度：不大于log<sub>2</sub>n的最大整数+1</li></ul><h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><ul><li>将编号为i的结点元素存放在一维数组下标为i-1的分量中</li><li>仅适用与完全二叉树</li></ul><h5 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><ul><li>结点由数据域和左右指针构成 – 二叉链表</li><li>还可在结点结构中增加一个指向其双亲结点的指针域 – 三叉链表</li></ul><h5 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h5><ul><li>先序(根)遍历</li><li>中序(根)遍历</li><li>后序(根)遍历</li></ul><h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><ul><li>增加LTag，RTag两个标志域</li><li>LTag为0，lchild域指示结点的左孩子，LTag为1，lchild域指示结点的前驱</li><li>RTag为0，rchild域指示结点的右孩子，RTag为1，rchild域指示结点的后继</li><li>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表</li><li>指向结点前驱和后继的指针叫做线索</li><li>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化</li></ul><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ul><li>双亲表示法</li><li>孩子表示法</li><li>孩子兄弟表示法</li></ul><h3 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h3><ul><li>给定一棵树，可以找到惟一的一棵二叉树与之对应，从物理结构上看，它们的二叉链表相同，只是解释不同</li></ul><h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><h3 id="赫夫曼-Huffman-树-–-最优树"><a href="#赫夫曼-Huffman-树-–-最优树" class="headerlink" title="赫夫曼(Huffman)树 – 最优树"></a>赫夫曼(Huffman)树 – 最优树</h3><ul><li>一类带权路径长度最短的树</li><li>路径长度：路径上的分支数目</li><li>树的路径长度是从树根到每个结点的路径长度之和</li><li>树的带权路径长度为树中所有叶子结点的带权路径长度之和，记作WPL</li><li>n个叶子结点构造的树中，WPL最小的二叉树为最优二叉树或赫夫曼树</li></ul><h5 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组与广义表</title>
    <link href="/2018/03/27/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2018/03/27/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组一旦被定义，它的维数和维界就不在改变</li><li>一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组。同理，一个n维数组类型可以定义为其数据元素为n-1维数组类型的一维数组类型</li></ul><a id="more"></a><ul><li>二维数组可有两种存储方式，一种是以行序为主序的存储方式（行优先），一种是以列序为主序的存储方式（列优先）</li></ul><h3 id="广义表（列表-lists）"><a href="#广义表（列表-lists）" class="headerlink" title="广义表（列表-lists）"></a>广义表（列表-lists）</h3><ul><li>广义表一般记作<code>LS=(a1,a2,...,an)</code> </li><li>a<sub>i</sub>可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表</li><li>称第一个元素a<sub>1</sub>为LS的表头(Head)，称其余元素组成的表(a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>)是LS的表尾(Tail)</li><li>通常采用链式存储结构</li><li>广义表的深度定义为广义表中括弧的重数</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串</title>
    <link href="/2018/03/27/%E4%B8%B2/"/>
    <url>/2018/03/27/%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="串（string）-或字符串"><a href="#串（string）-或字符串" class="headerlink" title="串（string）(或字符串)"></a>串（string）(或字符串)</h4><ul><li>由零个或多个字符组成的有限序列</li><li>空串：长度为零的串</li><li>子串：串中任意个连续的字符组成的子序列</li><li>空格串：由一个或多个空格组成的串</li><li>‘\0’：结束标记</li></ul><a id="more"></a><h4 id="串的表示与实现"><a href="#串的表示与实现" class="headerlink" title="串的表示与实现"></a>串的表示与实现</h4><p>定长顺序存储表示</p><ul><li>用一组地址连续的存储单元存储串值的字符序列。</li><li>为每个定义的串变量分配一个固定长度的存储区</li><li>超过预定义长度的串值被省去，称之为“截断”</li></ul><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> str[maxSize+<span class="hljs-number">1</span>];    <span class="hljs-comment">//多出一个'\0'作为结束标记</span>    <span class="hljs-keyword">int</span> length;&#125;Str;</code></pre><p>变长分配存储（动态分配存储）</p><ul><li>在使用时，需要用函数malloc()来分配一个长度为length、类型为char型的连续存储空间</li><li>分配的空间可以用free()释放</li></ul><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> *ch; <span class="hljs-comment">//指向动态分配存储区首地址的字符指针</span>    <span class="hljs-keyword">int</span> length;&#125;Str;</code></pre><pre><code class="hljs ?">堆分配存储表示- 以一组地址连续的存储单元存放串值字符序列- 存储空间是在程序执行过程中动态分配而得块链存储表示- 采用链表方式存储串值</code></pre><h4 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h4><ul><li>模式匹配：子串的定位操作</li><li><code>Index(S, T, pos)</code> </li><li>子串T称为模式串</li><li>从主串S的第pos个字符起和模式的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起再重新和模式的字符比较之。依次类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，函数值为和模式T中的第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零</li><li>此字符串存储在1-length位置上</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index</span><span class="hljs-params">(Str str, Str subStr)</span><span class="hljs-comment">//str:主串 subStr:子串</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,k=i;    <span class="hljs-keyword">while</span>(i&lt;=str.length &amp;&amp; j&lt;=subStr.length)    &#123;        <span class="hljs-keyword">if</span>(str.ch[i] == subStr.ch[j])        &#123;            ++i;            ++j;        &#125;        <span class="hljs-keyword">else</span>        &#123;            j=<span class="hljs-number">1</span>;            i=++k;        &#125;    &#125;    <span class="hljs-keyword">if</span>(j&gt;subStr.length)        <span class="hljs-keyword">return</span> k;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="克努特-莫里斯-普拉特操作（简称为KMP法）"><a href="#克努特-莫里斯-普拉特操作（简称为KMP法）" class="headerlink" title="克努特-莫里斯-普拉特操作（简称为KMP法）"></a>克努特-莫里斯-普拉特操作（简称为KMP法）</h4><ul><li>每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右滑动尽可能多的一段距离后，继续进行比较</li><li>next数组：模式串j处不匹配时，应从next[j]处的字符开始重新与主串进行比较</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(Str subStr, <span class="hljs-keyword">int</span> next[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;    next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i&lt;subStr.length)    &#123;        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||subStr.ch[i]==subStr.ch[j])        &#123;            ++i;            ++j;            next[i]=j;        &#125;        <span class="hljs-keyword">else</span>            j=next[j];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(Str str,Str subStr,<span class="hljs-keyword">int</span> next[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(i&lt;=str.length &amp;&amp; j&lt;=substr.length)    &#123;        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||str.ch[i]==subStr.ch[j])        &#123;            ++i;            ++j;        &#125;        <span class="hljs-keyword">else</span>            j=next[j];    &#125;    <span class="hljs-keyword">if</span>(j&gt;subStr.length)        <span class="hljs-keyword">return</span> i-subStr.length;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="https-blog-csdn-net-v-july-v-article-details-7041827"><a href="#https-blog-csdn-net-v-july-v-article-details-7041827" class="headerlink" title="https://blog.csdn.net/v_july_v/article/details/7041827"></a><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2018/03/26/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2018/03/26/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><ul><li>仅限在表尾进行插入和删除操作的线性表</li><li>表尾端称为栈顶（top）</li><li>表头端称为栈底（bottom）</li><li>后进先出（last in first out）的线性表（简称LIFO结构）</li></ul><a id="more"></a><ul><li>入栈（Push）</li><li>出栈（Pop）</li><li>栈按存储结构可分为顺序栈和链式栈</li><li>非法状态：上溢（栈满时继续入栈）、下溢（栈空时继续出栈）</li></ul><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><pre><code class="hljs c"><span class="hljs-comment">//定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data[maxSize];<span class="hljs-comment">//存放栈中元素</span>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span>&#125; SqStack;<span class="hljs-comment">//初始化栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(SqStack &amp;st)</span></span><span class="hljs-function"></span>&#123;    st.top = <span class="hljs-number">-1</span>;<span class="hljs-comment">//top为-1时，栈为空</span>&#125;<span class="hljs-comment">//判断栈是否为空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqStack st)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-keyword">if</span>(st.top == <span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//进栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(SqStack &amp;st, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(st.top == maxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，不能进栈</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    ++(st.top);    st.data[st.top] = x;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//出栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(SqStack &amp;st, <span class="hljs-keyword">int</span> &amp;x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(st.top == <span class="hljs-number">-1</span>) <span class="hljs-comment">//栈空，不能出栈</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    x = st.data[st.top];<span class="hljs-comment">//取出栈顶元素</span>    --(st.top);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><pre><code class="hljs c"><span class="hljs-comment">//链栈结点定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//数据域</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span>&#125; LNode;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(LNode *&amp;lst)</span></span><span class="hljs-function"></span>&#123;    lst = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<span class="hljs-comment">//制造一个头结点</span>    lst-&gt;next = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">//进栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(LNode *lst, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    LNode *p;    p = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<span class="hljs-comment">//为进栈元素申请结点空间</span>    p-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//头插法</span>    p-&gt;data = x;    p-&gt;next = lst-&gt;next;    lst-&gt;next = p;&#125;<span class="hljs-comment">//出栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(LNode *lst, <span class="hljs-keyword">int</span> &amp;x)</span></span><span class="hljs-function"></span>&#123;    LNode *p;    <span class="hljs-keyword">if</span>(lst-&gt;next = <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//判断栈是否为空</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    p = lst-&gt;next;    x = p-&gt;data;    lst-&gt;next = p-&gt;next;    <span class="hljs-built_in">free</span>(p);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><ul><li>两个栈共享一片连续的存储空间，两个栈的栈底位于存储空间的两端，当两个栈的栈顶在栈空间的某处相遇时，产生上溢。</li></ul><h3 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h3><ul><li>先进先出（first In first out，FIFO）的线性表</li><li>队尾（rear）：允许插入元素的一端，队尾元素</li><li>队头（front）：允许删除元素的一端，队头元素</li><li>队列按存储结构可分为顺序队列和链队列</li></ul><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><pre><code class="hljs c"><span class="hljs-comment">//定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data[maxSize];    <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//队首指针</span>    <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//队尾指针</span>&#125;SqQueue;</code></pre><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><pre><code class="hljs c"><span class="hljs-comment">//队列结点定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//数据域</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span>&#125;QNode;<span class="hljs-comment">//链队列类型定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    QNode *front;<span class="hljs-comment">//队头指针</span>    QNode *rear;<span class="hljs-comment">//队尾指针</span>&#125;LiQueue;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(LiQueue *&amp;lqu)</span></span><span class="hljs-function"></span>&#123;    lqu=(LiQueue*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LiQueue));    lqu-&gt;front=lqu-&gt;rear=<span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">//判断队空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isQueueEmpty</span><span class="hljs-params">(LiQueue *lqu)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(lqu-&gt;rear==<span class="hljs-literal">NULL</span>||lqu-&gt;front==<span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(LiQueue *lqu,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    QNode *p;    p=(QNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));    p-&gt;data=x;    p-&gt;next=<span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(lqu-&gt;rear==<span class="hljs-literal">NULL</span>)        lqu-&gt;front=lqu-&gt;rear=p;    <span class="hljs-keyword">else</span>    &#123;        lqu-&gt;rear-&gt;next=p;        lqu-&gt;rear=p;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(LiQueue *lqu,<span class="hljs-keyword">int</span> &amp;x)</span></span><span class="hljs-function"></span>&#123;    QNode *p;    <span class="hljs-keyword">if</span>(lqu-&gt;rear==<span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span>        p=lqu-&gt;front;    <span class="hljs-keyword">if</span>(lqu-&gt;front==lqu-&gt;rear)        lqu-&gt;front=lqu-&gt;rear=<span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">else</span>        lqu-&gt;front=lqu-&gt;front-&gt;next;    x=p-&gt;data;    <span class="hljs-built_in">free</span>(p);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul><li>队列为空：qu.front == qu.rear</li><li>队列为满：(qu.rear+1)%maxSize == qu.front</li><li>非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置</li><li>假溢出：普通顺序队列在一系列进队出队操作后，两个指针最终都会到达数组末端maxSize-1处，虽然队列中没有元素或元素未满，都不能让新元素入队。因此使用循环队列</li></ul><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue &amp;qu)</span></span><span class="hljs-function"></span>&#123;    qu.front=qu.rear=<span class="hljs-number">0</span>;<span class="hljs-comment">//队首队尾指针重合，并指向0</span>&#125;<span class="hljs-comment">//进队</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue &amp;qu, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>((qu.rear+<span class="hljs-number">1</span>)%maxSize==qu.front)<span class="hljs-comment">//判断队满</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    qu.rear=(qu.rear+<span class="hljs-number">1</span>)%maxSize;<span class="hljs-comment">//先移动指针</span>    qu.data[qu.rear]=x;<span class="hljs-comment">//存入元素</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//出队</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue &amp;qu, <span class="hljs-keyword">int</span> &amp;x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(qu.front==qu.rear)<span class="hljs-comment">//判断队空</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；   qu.front=(qu.front+<span class="hljs-number">1</span>)%maxSize;<span class="hljs-comment">//队非空，移动指针</span>    x=qu.data[qu.front];<span class="hljs-comment">//取出元素</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><ul><li>一种插入和删除操作在两端均可进行的线性表</li><li>输入受限的双端队列：允许在一端进行插入和删除（进队和出队），另一端只允许删除</li><li>输出受限的双端队列：允许在一端进行插入和删除（进队和出队），另一端只允许插入</li></ul><p>算术表达式三种形式</p><p>前缀</p><p>中缀</p><p>后缀</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Canvas</title>
    <link href="/2018/03/20/canvas/"/>
    <url>/2018/03/20/canvas/</url>
    
    <content type="html"><![CDATA[<p><code>&lt;canvas&gt;</code> 默认大小为width:300px;height:150px;</p><ul><li><p>可以通过html设置宽髙，用css设置宽髙可能会导致图像扭曲</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tutorial"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span></code></pre></li></ul><a id="more"></a><ul><li><p>使用getContext()方法获得渲染上下文和它的绘画功能</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'tutorial'</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);</code></pre></li></ul><h3 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h3><ul><li><p>矩形</p><p>canvas只支持一种原生的图形绘制：矩形。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>); <span class="hljs-keyword">if</span> (canvas.getContext) &#123; <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);    <span class="hljs-comment">//以(25,25)为起点绘制一个宽髙为100的矩形</span> ctx.fillRect(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);    <span class="hljs-comment">//清除指定的矩形区域</span> ctx.clearRect(<span class="hljs-number">45</span>,<span class="hljs-number">45</span>,<span class="hljs-number">60</span>,<span class="hljs-number">60</span>);    <span class="hljs-comment">//绘制一个矩形边框</span> ctx.strokeRect(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>); &#125;&#125;</code></pre></li><li><p>绘制路径</p><p><code>beginPath()</code>  – 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</p><p><code>closePath()</code>  – 闭合路径之后图形绘制命令又重新指向到上下文中。</p><p><code>stroke()</code> – 通过线条来绘制图形轮廓。</p><p><code>fill()</code> – 通过填充路径的内容区域生成实心的图形，当调用fill()函数的时候，所有没有闭合的形状都会自动闭合。</p></li><li><p>移动笔触</p><p><code>moveTo(x, y)</code> – 将笔触移动到指定的坐标上。</p></li><li><p>线</p><p><code>lineTo(x, y)</code> – 绘制一条从当前位置到指定位置的直线。</p></li><li><p>绘制三角形</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>); <span class="hljs-keyword">if</span> (canvas.getContext)&#123;     <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);     <span class="hljs-comment">// 填充三角形</span>     ctx.beginPath();     ctx.moveTo(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);     ctx.lineTo(<span class="hljs-number">105</span>,<span class="hljs-number">25</span>);     ctx.lineTo(<span class="hljs-number">25</span>,<span class="hljs-number">105</span>);     ctx.fill();     <span class="hljs-comment">// 描边三角形</span>     ctx.beginPath();     ctx.moveTo(<span class="hljs-number">125</span>,<span class="hljs-number">125</span>);     ctx.lineTo(<span class="hljs-number">125</span>,<span class="hljs-number">45</span>);     ctx.lineTo(<span class="hljs-number">45</span>,<span class="hljs-number">125</span>);     ctx.closePath();     ctx.stroke(); &#125;&#125;</code></pre></li><li><p>圆弧</p><p><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code> – 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</p><p><code>arcTo(x1, y1, x2, y2, radius)</code> – 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p></li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li><p><code>fillStyle = color</code> – 设置图形的填充颜色。</p></li><li><p><code>strokeStyle = color</code> – 设置图形轮廓的颜色。</p><pre><code class="hljs javascript">ctx.fillStyle = <span class="hljs-string">"orange"</span>;ctx.fillStyle = <span class="hljs-string">"#FFA500"</span>;ctx.fillStyle = <span class="hljs-string">"rgb(255,165,0)"</span>;ctx.fillStyle = <span class="hljs-string">"rgba(255,165,0,1)"</span>;</code></pre></li><li><p><code>lineWidth = value</code> – 设置线条宽度。</p></li></ul><p><a href="https://github.com/juzi123/canvas-2018" target="_blank" rel="noopener">Canvas画板</a> </p><p>参考文献：<a href="https://developer.mozilla.org/zh-CN/search?q=canvas" target="_blank" rel="noopener">MDN-Canvas</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2018/03/15/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2018/03/15/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="线性表–n个数据元素的有限序列"><a href="#线性表–n个数据元素的有限序列" class="headerlink" title="线性表–n个数据元素的有限序列"></a>线性表–n个数据元素的有限序列</h4><ul><li><p>一个数据元素可以由若干个数据项组成。</p></li><li><p>同一线性表中的元素必定具有相同特性，即属同一数据对象</p></li><li><p>i称为a<sub>i</sub>在线性表中的位序</p></li><li><p>a<sub>i-1</sub>称为a<sub>i</sub>的直接前驱元素</p><p>a<sub>i</sub>称为a<sub>i-1</sub>的直接后继元素</p></li><li><p>n=0时称为空表</p></li><li><p>线性表的存储结构有顺序存储结构和链式存储结构</p></li></ul><a id="more"></a><h4 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h4><ul><li>用一组地址连续的存储单元依次存储线性表的数据元素</li><li>通常称这种存储结构的线性表为顺序表</li><li>随机访问特性：通过序号可以找到任意位置的数据</li><li>占用连续的存储空间</li></ul><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxSize 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data[maxSize];  <span class="hljs-comment">//存放顺序表元素的数组</span>    <span class="hljs-keyword">int</span> length;  <span class="hljs-comment">//顺序表的长度</span>&#125;Sqlist;   <span class="hljs-comment">//顺序表类型的定义</span></code></pre><p>####顺序表的增删改查</p><ul><li>顺序表在做插入删除操作时需要移动多个元素</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查找x</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;        <span class="hljs-keyword">if</span>(x == L.data[i])&#123;<span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">//在顺序表L的第p个位置插入元素e</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertElem</span><span class="hljs-params">(Sqlist &amp;L, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> e)</span>  <span class="hljs-comment">//引用型</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">0</span>||p&gt;L.length||L.length==maxSize)  <span class="hljs-comment">//位置错误或表长已经达到最大值</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=length<span class="hljs-number">-1</span>;i&gt;=p;--i)&#123;        L.data[i+<span class="hljs-number">1</span>] = L.data[i];    &#125;    L.data[p] = e;    ++(L.length);  <span class="hljs-comment">//表长加1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//插入成功，返回1</span>&#125;<span class="hljs-comment">//删除顺序表L中下标为p的元素，并把删除的元素的值赋给e</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteElem</span><span class="hljs-params">(Sqlist &amp;L, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> &amp;e)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">0</span>||p&gt;L.length<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    e=L.data[p];    <span class="hljs-keyword">for</span>(i=p;i&lt;L.length<span class="hljs-number">-1</span>;++i)&#123;        L.data[i] = L.data[i+<span class="hljs-number">1</span>];  <span class="hljs-comment">//p位置开始，后边的元素逐个前移一个位置</span>    &#125;    --(L.length);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h4 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h4><ul><li>任意的存储单元</li><li>结点：由数据域和指针域构成</li><li>数据域：存储数据元素信息的域</li><li>指针域：存储直接后继存储位置的域，指针（链）</li><li>链表：线性表的链式存储结构</li><li>线性链表（单链表）：结点中只包含一个指针域</li><li>头结点：有时在单链表第一个结点之前附设的结点，头结点的数据域可以不存储任何信息，也可存储线性表的长度等类的附加信息</li><li>带头结点的单链表中，头指针head指向头结点，head-&gt;next为NULL时，链表为空；不带头结点的单链表中的头指针head直接指向开始结点，当head等于NULL时，链表为空。</li><li>不支持随机访问，结点的存储空间利用率较顺序表稍低，支持存储空间的动态分配</li></ul><h4 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h4><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data;  <span class="hljs-comment">//data中存放结点数据域</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指向后继结点的指针</span>&#125;LNode; <span class="hljs-comment">//定义单链表结构类型</span></code></pre><h4 id="单链表的增删改查"><a href="#单链表的增删改查" class="headerlink" title="单链表的增删改查"></a>单链表的增删改查</h4><ul><li>链表的增删操作不需要移动元素，只需要修改指针</li></ul><pre><code class="hljs c"><span class="hljs-comment">//完整的删除操作</span>q = p-&gt;next;<span class="hljs-comment">//要删除的结点</span>p-&gt;next = p-&gt;next-&gt;next;<span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//调用free函数释放q所指结点的空间</span></code></pre><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><pre><code class="hljs c"><span class="hljs-comment">//有n个元素已经存储在数组a中，用尾插法建立链表C</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createlistR</span><span class="hljs-params">(LNode *&amp;C, <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    LNode *s, *r;<span class="hljs-comment">//s用来指向新申请的结点，r始终指向C的终端结点</span>    <span class="hljs-keyword">int</span> i;    C = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<span class="hljs-comment">//申请C的头结点空间</span>    C-&gt;next = <span class="hljs-literal">NULL</span>;    r = C;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)    &#123;        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));        s-&gt;data = a[i];<span class="hljs-comment">//用新申请的结点来接收a中的一个元素</span>        r-&gt;next = s;<span class="hljs-comment">//用r来接纳新结点</span>       r = r-&gt;next;<span class="hljs-comment">//r指向终端结点，以便接纳下一个到来的结点</span>    &#125;    r-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//将C的终端结点指针域置为NULL，C建立完成</span>&#125;</code></pre><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createlistF</span><span class="hljs-params">(LNode *&amp;C, <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    LNode *s;    <span class="hljs-keyword">int</span> i;    C = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));    C-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));        s-&gt;data = a[i];        s-&gt;next = C-&gt;next;<span class="hljs-comment">//s所指新结点的指针域next指向C中的开始结点</span>        C-&gt;next = s;<span class="hljs-comment">//头结点的指针域next指向s结点，使得s成为新的开始结点</span>    &#125;&#125;</code></pre><h4 id="单链表的合并"><a href="#单链表的合并" class="headerlink" title="单链表的合并"></a>单链表的合并</h4><pre><code class="hljs c"><span class="hljs-comment">//将A，B两个元素递增有序的单链表(含头结点)合并成一个按元素值非递减有序的链表C</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(LNode *A, LNode *B, LNode *&amp;C)</span></span><span class="hljs-function"></span>&#123;    LNode *p = A-&gt;next;<span class="hljs-comment">//p跟踪A的最小值结点</span>    LNode *q = B-&gt;next;<span class="hljs-comment">//q跟踪B的最小值结点</span>    LNdoe *r;<span class="hljs-comment">//r指向C的终端结点</span>    C = A;    C-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-built_in">free</span>(B);<span class="hljs-comment">//B的头结点已无用，释放</span>    r = C;<span class="hljs-comment">//r指向C，此时头结点也是终端结点</span>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-keyword">if</span>(p-&gt;data &lt;= q-&gt;data)        &#123;            r-&gt;next = p;            p = p-&gt;next;            r = r-&gt;next;        &#125;        <span class="hljs-keyword">else</span>        &#123;            r-&gt;next = q;            q = q-&gt;next；            r = r-&gt;next;        &#125;    &#125;    <span class="hljs-comment">//r-&gt;next = NULL;</span>    <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>) r-&gt;next = p;    <span class="hljs-keyword">if</span>(q != <span class="hljs-literal">NULL</span>) r-&gt;next = q;&#125;</code></pre><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><ul><li>借助一维数组实现</li><li>数组中的每个结点含有两个分量：一个数据元素分量，一个指针分量，指示当前结点的直接后继结点在数组中的位置</li><li>指针分量不是通常的存储内存地址的指针型变量，而是一个存储数组下标的整型变量</li></ul><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul><li>表中最后一个结点的指针域指向头结点，整个链表形成一个环</li></ul><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul><li>结点有两个指针域，一个指向直接后继，一个指向直接前驱</li></ul><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span> *<span class="hljs-title">prior</span>;</span> <span class="hljs-comment">//指向前驱结点的指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指向后继结点的指针</span>&#125;DLNode;  <span class="hljs-comment">//定义双链表结点类型</span></code></pre><h4 id="循环双向链表"><a href="#循环双向链表" class="headerlink" title="循环双向链表"></a>循环双向链表</h4><pre><code class="hljs c"><span class="hljs-comment">//以下4句任意一句为真，即可判断循环双链表为空</span>head-&gt;next == head;head-&gt;prior == head;head-&gt;next == head &amp;&amp; head-&gt;prior == head;head-&gt;next == head || head-&gt;prior == head;</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪类与伪元素</title>
    <link href="/2018/03/12/%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BC%AA%E7%B1%BB/"/>
    <url>/2018/03/12/%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BC%AA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><h2 id="伪类的定义"><a href="#伪类的定义" class="headerlink" title="伪类的定义"></a>伪类的定义</h2><p>伪类存在的意义是为了通过选择器找到那些不存在于DOM树中的信息以及不能被常规CSS选择器获取到的信息</p><p>伪类由一个冒号<code>：</code> 开头，冒号后跟伪类的名称和包含在圆括号中的可选参数</p><p>任何常规选择器可以再任何位置使用伪类。伪类语法不区别大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作DOM时产生的DOM结构改变，伪类也可以是动态的。</p><a id="more"></a><h2 id="伪类举例"><a href="#伪类举例" class="headerlink" title="伪类举例"></a>伪类举例</h2><ul><li><p><code>:hover</code></p><p>鼠标放在链接上的状态</p></li><li><p><code>:active</code></p><p>正在活动链接</p></li><li><p><code>:visited</code></p><p>选择所有访问过的链接</p></li><li><p><code>:link</code></p><p>选择所有未访问链接</p></li><li><p><code>:focus</code></p><p>将样式添加到被选中的元素</p></li><li><p><code>:lang</code></p><p>允许作者来定义指定的元素中使用的语言</p></li><li><p><code>:first-child</code></p><p>选择元素的第一个子元素</p></li></ul><p><img src="/blogImg/%E4%BC%AA%E7%B1%BB.png" srcset="/img/loading.gif" alt="伪类"> </p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><h2 id="伪元素的定义"><a href="#伪元素的定义" class="headerlink" title="伪元素的定义"></a>伪元素的定义</h2><p>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）。比如：document接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使开发者可以提取到这些信息。并且，一些伪元素可以使开发者获取到不存在于源文档中的内容（比如常见的<code>::before</code>,<code>::after</code>）。</p><p>伪元素的由<strong>两个冒号</strong><code>::</code>开头，然后是伪元素的名称。</p><p>使用两个冒号<code>::</code>是为了区别伪类和伪元素（CSS2中并没有区别）。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号<code>:</code>的语法，但是CSS3中新增的伪元素必须使用两个冒号<code>::</code>。</p><p>目前一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。</p><h2 id="伪元素举例"><a href="#伪元素举例" class="headerlink" title="伪元素举例"></a>伪元素举例</h2><ul><li><p><code>::first-line</code></p><p>用于向文本的首行设置特殊样式</p></li><li><p><code>::first-letter</code></p><p>用于向文本的首字母设置特殊样式</p></li><li><p><code>::before</code></p><p>可以在元素前插入内容</p></li><li><p><code>::after</code> </p><p>可以在元素的内容后插入新内容</p></li></ul><p><img src="/blogImg/%E4%BC%AA%E5%85%83%E7%B4%A0.png" srcset="/img/loading.gif" alt="伪元素"> </p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.cnblogs.com/ihardcoder/p/5294927.html" target="_blank" rel="noopener">CSS3伪类和伪元素的特性和区别</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">mdn</a> </p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行内元素与块级元素</title>
    <link href="/2018/03/12/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2018/03/12/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="内联元素-行内元素"><a href="#内联元素-行内元素" class="headerlink" title="内联元素(行内元素)"></a>内联元素(行内元素)</h3><p>一个内联元素只占据它对应标签的边框所包含的空间</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  这是一个<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>行内元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;  <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> red solid;&#125;</code></pre><p><img src="/blogImg/css2-1.png" srcset="/img/loading.gif" alt="行内元素">   </p><a id="more"></a><p>内联元素只能容纳文本和其他内联元素，内联元素的高度，行高以及顶和底边距不能改变，宽度即为容纳文本和图片的宽度，不可改变。</p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>块级元素占据其父元素（容器）的整个空间，通常浏览器会在块级元素前后另起一个新行。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;  <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> blue solid;&#125;</code></pre><p><img src="/blogImg/css2-2.png" srcset="/img/loading.gif" alt="块级元素">  </p><p>块级元素可以容纳其他块级元素和内联元素，宽度默认是它容器的100%，除非设定一个宽度。</p><h3 id="内联元素与块级元素转换"><a href="#内联元素与块级元素转换" class="headerlink" title="内联元素与块级元素转换"></a>内联元素与块级元素转换</h3><ul><li><p>display</p><p>块级元素默认为<code>display:block</code> </p><p>内联元素默认为<code>display:inline</code> </p><p><code>display:inline-block</code> 既具有block的宽度高度特性又具有inline的同行特性</p><p><code>display:none</code> 不显示该元素，也不会保留该元素原先占有的文档流位置。<br><code>display:block</code> 转换为块级元素。<br><code>display:inline</code> 转换为行内元素。</p></li><li><p>行内元素设置float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。</p></li><li><p>当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。</p></li></ul><h3 id="内联元素举例"><a href="#内联元素举例" class="headerlink" title="内联元素举例"></a>内联元素举例</h3><p>a - 锚点</p><p>abbr - 缩写</p><p>big - 大字体</p><p>br - 换行</p><p>cite - 引用</p><p>code - 计算机代码</p><p>dfn - 定义字段</p><p>em - 强调</p><p>i - 斜体</p><p>img - 图片</p><p>input - 输入框</p><p>kdb - 键盘文本</p><p>label - 表格标签</p><p>q - 短引用</p><p>samp - 计算机代码</p><p>select - 项目选择</p><p>small - 小字体文本</p><p>span - 常用内联容器</p><p>strike - 中划线</p><p>strong - 粗体表强调</p><p>sub - 上标</p><p>sup - 下标</p><p>textarea - 多行文本输入框</p><p>u - 下划线</p><p>var - 定义变量</p><h3 id="块级元素举例"><a href="#块级元素举例" class="headerlink" title="块级元素举例"></a>块级元素举例</h3><p>address - 地址</p><p>blockquote - 块引用</p><p>center -居中对齐块</p><p>dir - 目录列表</p><p>div - 常用块级容器</p><p>dl - 定义列表</p><p>form - 交互表单</p><p>h1~h6 - 标题</p><p>hr - 水平分隔线</p><p>menu - 菜单列表</p><p>noscript - 不支持script显示内容</p><p>ol - 有序列表</p><p>p - 段落</p><p>pre - 格式化文本</p><p>table - 表格</p><p>ul - 无序列表</p><h3 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h3><p>可变元素由上下文语境来决定是块元素还是内联元素。</p><p>applet - java applet</p><p>button - 按钮</p><p>del - 删除文本</p><p>iframe - inline frame</p><p>ins - 插入的文本</p><p>map - 图片区块（map）</p><p>object - object对象</p><p>script - 客户端脚本</p><p>参考文献：</p><p><a href="https://www.jianshu.com/p/274614a078f3" target="_blank" rel="noopener">说说行内元素与块级元素以及之间的转换？</a></p><p><a href="http://www.nowamagic.net/librarys/veda/detail/1190" target="_blank" rel="noopener">CSS块级元素、内联元素概念</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements" target="_blank" rel="noopener">MDN</a> </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用布局方法</title>
    <link href="/2018/03/11/%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/"/>
    <url>/2018/03/11/%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="常用布局的实现方法"><a href="#常用布局的实现方法" class="headerlink" title="常用布局的实现方法"></a>常用布局的实现方法</h1><h2 id="一、水平居中"><a href="#一、水平居中" class="headerlink" title="一、水平居中"></a>一、水平居中</h2><h3 id="文本-行内元素-行内块级元素"><a href="#文本-行内元素-行内块级元素" class="headerlink" title="文本/行内元素/行内块级元素"></a>文本/行内元素/行内块级元素</h3><p>针对行内元素和display属性为inline的块状元素</p><p>通过给父元素设置<code>text-align:center</code>实现。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">text-align</span>: center;&#125;<span class="hljs-selector-class">.div1</span>&#123;    <span class="hljs-attribute">display</span>: inline;    <span class="hljs-attribute">text-align</span>: center;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"div1"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"div2"</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>22222<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>子元素不能受到float影响；属性会继承影响到后代行内内容； 如果子元素宽度大于父元素宽度则无效，只有后代行内内容中宽度小于设置text-align属性的元素宽度的时候，才会水平居中  </p><h3 id="单个块级元素"><a href="#单个块级元素" class="headerlink" title="单个块级元素"></a>单个块级元素</h3><p> 在margin有节余的同时如果左右margin设置了auto，将会均分剩余空间。另外，如果上下的margin设置了auto，其计算值为0 </p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#son</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/*必须定宽*/</span>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;</code></pre></div><h3 id="多个块级元素"><a href="#多个块级元素" class="headerlink" title="多个块级元素"></a>多个块级元素</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">text-align</span>: center;&#125;<span class="hljs-selector-class">.son</span>&#123;    <span class="hljs-attribute">display</span>: inline-block; <span class="hljs-comment">/*改为行内或者行内块级形式，以达到text-align对其生效*/</span>&#125;</code></pre></div><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的 </p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-comment">/*定宽*/</span>    <span class="hljs-attribute">position</span>: relative;  <span class="hljs-comment">/*父相*/</span>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;&#125;<span class="hljs-selector-id">#son</span>&#123;    <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-comment">/*子绝*/</span>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;  <span class="hljs-comment">/*父元素宽度一半,这里等同于left:100px*/</span>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);  <span class="hljs-comment">/*自身宽度一半,等同于margin-left: -50px;*/</span>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-comment">/*定宽*/</span>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;&#125;</code></pre></div><h3 id="任意个元素-flex"><a href="#任意个元素-flex" class="headerlink" title="任意个元素  flex"></a>任意个元素  flex</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">justify-content</span>: center;&#125;</code></pre></div><h2 id="二、垂直居中"><a href="#二、垂直居中" class="headerlink" title="二、垂直居中"></a>二、垂直居中</h2><h3 id="单行文本-行内元素-行内块级元素"><a href="#单行文本-行内元素-行内块级元素" class="headerlink" title="单行文本/行内元素/行内块级元素"></a>单行文本/行内元素/行内块级元素</h3><p> line-height的最终表现是通过inline box实现的，而无论inline box所占据的高度是多少（无论比文字大还是比文字小），其占据的空间都是与文字内容公用水平中垂线的。 </p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">150px</span>;  <span class="hljs-comment">/*与height等值*/</span>&#125;</code></pre></div><h3 id="多行文本-行内元素-行内块级元素"><a href="#多行文本-行内元素-行内块级元素" class="headerlink" title="多行文本/行内元素/行内块级元素"></a>多行文本/行内元素/行内块级元素</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;  <span class="hljs-comment">/*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/</span>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;  <span class="hljs-comment">/*元素在页面呈现为5行,则line-height的值为height/5*/</span>&#125;</code></pre></div><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">img</span><span class="hljs-selector-id">#son</span>&#123;<span class="hljs-attribute">vertical-align</span>: middle;&#125; <span class="hljs-comment">/*默认是基线对齐，改为middle*/</span></code></pre></div><h3 id="单个块级元素-1"><a href="#单个块级元素-1" class="headerlink" title="单个块级元素"></a>单个块级元素</h3><div class="hljs"><pre><code class="hljs css">&lt;div id="parent"&gt;    &lt;div id="son"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></div><h4 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">display</span>: table-cell;    <span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre></div><p>设置tabl-cell的元素，宽度和高度的值设置百分比无效，需要给它的父元素设置display: table; 才生效；table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；设置float或position会对默认布局造成破坏，可以考虑为之增加一个父div定义float等属性；内容溢出时会自动撑开父元素</p><h4 id="绝对定位-1"><a href="#绝对定位-1" class="headerlink" title="绝对定位"></a>绝对定位</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的*/</span><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">position</span>: relative;  <span class="hljs-comment">/*父相*/</span>&#125;<span class="hljs-selector-id">#son</span>&#123;    <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-comment">/*子绝*/</span>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;  <span class="hljs-comment">/*父元素高度一半,这里等同于top:75px;*/</span>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);  <span class="hljs-comment">/*自身高度一半,这里等同于margin-top:-25px;*/</span>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;&#125;<span class="hljs-comment">/*优缺点</span><span class="hljs-comment">- 优点：使用margin-top兼容性好；不管是块级还是行内元素都可以实现</span><span class="hljs-comment">- 缺点：代码较多；脱离文档流；使用margin-top需要知道高度值；使用transform兼容性不好（ie9+）*/</span>或<span class="hljs-comment">/*原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分*/</span><span class="hljs-selector-id">#parent</span>&#123;<span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-id">#son</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">margin</span>: auto <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;&#125;<span class="hljs-comment">/*优缺点</span><span class="hljs-comment">- 优点：简单;兼容性较好(ie8+)</span><span class="hljs-comment">- 缺点：脱离文档流*/</span></code></pre></div><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">align-items</span>: center;&#125;或<span class="hljs-selector-id">#parent</span>&#123;<span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-id">#son</span>&#123;<span class="hljs-attribute">align-self</span>: center;&#125;或<span class="hljs-comment">/*原理：这个尚未搞清楚，应该是flex使margin上下边界无限延伸至剩余空间并平分了*/</span><span class="hljs-selector-id">#parent</span>&#123;<span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-id">#son</span>&#123;<span class="hljs-attribute">margin</span>: auto <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="任意个元素-flex-1"><a href="#任意个元素-flex-1" class="headerlink" title="任意个元素(flex)"></a>任意个元素(flex)</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">align-items</span>: center;&#125;或<span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.son</span>&#123;    <span class="hljs-attribute">align-self</span>: center;&#125;或 <span class="hljs-selector-id">#parent</span>&#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">flex-direction</span>: column;    <span class="hljs-attribute">justify-content</span>: center;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://github.com/Sweet-KK/css-layout" target="_blank" rel="noopener">https://github.com/Sweet-KK/css-layout</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS浮动属性的使用</title>
    <link href="/2018/03/10/CSS%E6%B5%AE%E5%8A%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/03/10/CSS%E6%B5%AE%E5%8A%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>float指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。</p><p>一个浮动元素是float的值不为none的元素。</p><h2 id="float的值"><a href="#float的值" class="headerlink" title="float的值"></a>float的值</h2><ul><li><p><code>left</code> </p><p>表示元素浮动在所在块容器的左侧</p></li><li><p><code>right</code> </p><p>表示元素浮动在所在块容器的右侧</p><a id="more"></a></li><li><p><code>none</code> </p><p>不进行浮动</p></li><li><p><code>inline-start</code> </p></li><li><p><code>inline-end</code> </p></li></ul><h2 id="浮动元素的定位"><a href="#浮动元素的定位" class="headerlink" title="浮动元素的定位"></a>浮动元素的定位</h2><p>当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在每个元素标签中添加</p><div class="hljs"><pre><code class="hljs html">style="float: left(right);"</code></pre></div><p>或</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">float</span>: left;&#125;</code></pre></div><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>在这些元素的父元素中添加</p><div class="hljs"><pre><code class="hljs cs"><span class="hljs-keyword">class</span>=<span class="hljs-string">"clearfix"</span></code></pre></div><p>clearfix的代码</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;<span class="hljs-attribute">display</span>: block;<span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><h2 id="clear属性"><a href="#clear属性" class="headerlink" title="clear属性"></a>clear属性</h2><p>使得一些元素的左右两侧不会有浮动元素</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.p1</span> &#123;<span class="hljs-attribute">clear</span>: left;&#125;<span class="hljs-selector-class">.p2</span> &#123;  <span class="hljs-attribute">clear</span>: right;&#125;<span class="hljs-selector-class">.p3</span> &#123;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><p>clear属性只对元素本身的布局起作用</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="/2018/03/05/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2018/03/05/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h3><p>[h1~h6]</p><pre><code class="hljs clean"># ~ ###### 后跟标题内容</code></pre><h3 id="2、代码块"><a href="#2、代码块" class="headerlink" title="2、代码块"></a>2、代码块</h3><h5 id="代码块标记"><a href="#代码块标记" class="headerlink" title="代码块标记"></a>代码块标记</h5><pre><code class="hljs autohotkey">​``` (后跟语言名)(回车)</code></pre><a id="more"></a><h3 id="3、列表"><a href="#3、列表" class="headerlink" title="3、列表"></a>3、列表</h3><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>或<span class="hljs-bullet">* </span>或+</code></pre><ul><li>red</li><li>green</li><li>blue</li></ul><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><pre><code class="hljs angelscript">数字加. 表示<span class="hljs-number">1.</span> <span class="hljs-number">2.</span></code></pre><ol><li>red</li><li>green</li><li>blue</li></ol><h3 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h3><p>支持多级引用</p><pre><code class="hljs ruby">&gt; <span class="hljs-meta">&gt;&gt;</span> <span class="hljs-meta">&gt;&gt;</span>&gt; .....</code></pre><h3 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h3><pre><code class="hljs markdown">![<span class="hljs-string">图片文本-可忽略</span>](<span class="hljs-link">图片地址</span>)</code></pre><p><img src="/blogImg/markdown1.jpg" srcset="/img/loading.gif" alt="你好">   </p><h3 id="6、行内标记"><a href="#6、行内标记" class="headerlink" title="6、行内标记"></a>6、行内标记</h3><pre><code class="hljs arcade">在行内用<span class="hljs-string">``</span>包围目标代码</code></pre><p>这是<code>hello</code> 行内标记的示例</p><h3 id="7、插入链接"><a href="#7、插入链接" class="headerlink" title="7、插入链接"></a>7、插入链接</h3><pre><code class="hljs markdown">[<span class="hljs-string">文本</span>](<span class="hljs-link">网址</span>)</code></pre><p><a href="www.baidu.com">百度</a> </p><h3 id="8、表格"><a href="#8、表格" class="headerlink" title="8、表格"></a>8、表格</h3><pre><code class="hljs gherkin">|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3 </span>|</code></pre><table><thead><tr><th>1</th><th align="center">2</th><th align="right">3</th></tr></thead><tbody><tr><td>4</td><td align="center">5</td><td align="right">6</td></tr><tr><td>左对齐</td><td align="center">居中</td><td align="right">右对齐</td></tr></tbody></table><h3 id="9、分隔符"><a href="#9、分隔符" class="headerlink" title="9、分隔符"></a>9、分隔符</h3><pre><code class="hljs asciidoc"><span class="hljs-bullet">*** </span>或---</code></pre><hr><hr><h3 id="10、脚注"><a href="#10、脚注" class="headerlink" title="10、脚注"></a>10、脚注</h3><pre><code class="hljs markdown">内容[^数字][<span class="hljs-symbol">^对应数字</span>]:<span class="hljs-link">填写的内容在文章末尾</span></code></pre><p>JavaScript<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="我还没学 ">[1]</span></a></sup></p><h3 id="11、斜体"><a href="#11、斜体" class="headerlink" title="11、斜体"></a>11、斜体</h3><pre><code class="hljs haxe"><span class="hljs-literal">_</span>内容<span class="hljs-literal">_</span>*内容*</code></pre><p><em>内容</em></p><h3 id="12、转义"><a href="#12、转义" class="headerlink" title="12、转义"></a>12、转义</h3><pre><code class="hljs livescript"><span class="hljs-string">\</span></code></pre><p>###</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>我还没学<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2018/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2018/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="协议（protocol）"><a href="#协议（protocol）" class="headerlink" title="协议（protocol）"></a>协议（protocol）</h2><p>计算机网络协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和接收或其他事件所采取的动作</p><a id="more"></a><h4 id="协议分层（layer）"><a href="#协议分层（layer）" class="headerlink" title="协议分层（layer）"></a>协议分层（layer）</h4><p>各层的所有协议被称为协议栈（protocol stack），因特网的协议栈由5个层次组成：</p><ul><li>物理层：将帧中的bit一个个移动至下一节点<ul><li>双绞铜线</li><li>同轴电缆</li><li>光纤</li></ul></li><li>链路层：链路层分组称为帧（frame）<ul><li>以太网</li><li>WiiFi</li><li>电缆接入网的DOCSIS协议</li></ul></li><li>网络层：数据报（datagram），通常简称IP层<ul><li>IP协议</li><li>一些路由选择协议</li></ul></li><li>运输层：运输协议，报文段（segment）<ul><li>TCP</li><li>UDP</li></ul></li><li>应用层：把位于应用层的信息分组称为报文（message）<ul><li>HTTP：提供Web文档的请求和传送</li><li>SMTP：提供电子邮件报文的传输</li><li>FTP：提供两个端系统之间的文件传输</li><li>DNS</li></ul></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><ul><li>客户-服务器体系结构（client-server architecture）：服务器接收客户主机发送的请求并相应，客户之间不直接通信</li><li>P2P体系结构（P2P architecture）：对等方主机之间直接通信，自拓展性(self-scalability)</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>多数应用程序通过通信进程对组成，每对中的两个进程互相发送报文</p><p>进程通过一个称为套接字（socket）的软件接口向网络发送报文和接收报文</p><p>可靠数据传输（reliable data transfer）：确保数据交付服务</p><p>应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li>超文本传输协议</li><li>使用TCP作为支撑运输协议</li><li>无状态协议（stateless protocol）：不保存客户的任何信息</li><li>Web浏览器实现了HTTP的客户端，Web服务器实现了HTTP的服务器端</li><li>使用HTTP协议访问另一个IP时，必须同时提供IP和端口号，缺一不可，浏览器添加了默认端口号80</li><li><a href="http://qq.com:80" target="_blank" rel="noopener">http://qq.com:80</a></li></ul><p>非持续链接（non-persistent connection）：每个请求和响应由一个单独的TCP链接发送</p><p>持续链接（persistent connection）：所有请求及响应经相同的TCP链接发送</p><p>往返时间（Round-Trip Time，RTT）：一个短分组从客户到服务器然后再返回客户的时间</p><p>HTTP报文格式</p><ul><li><p>请求报文</p><p>方法字段， URL字段， HTTP版本字段            /请求行（request line）</p><p>​                                        /首部行（header line）</p><p>HOST：指明对象所在主机</p><p>Connection：是否使用持续链接</p><p>User-agent：浏览器类型</p><p>Accept-language：语言版本</p></li></ul><ul><li>方法字段：GET、POST、HEAD、PUT、DELETE</li></ul><ul><li><p>响应报文</p><p>协议版本字段，状态码，响应状态信息            /初始状态行（status line）</p><p>​                                        /首部行</p><p>connection：</p><p>Date：发送该响应报文的日期时间</p><p>server：服务器类型</p><p>Last-Modeified：对象创建或最后修改的日期</p><p>Content-Length：发送对象字节数</p><p>Content-Type：实体体中的对象类型</p><p>​                                        /实体体（entity body）</p><p>（data data data ……)</p></li></ul><ul><li>状态码</li><li>200 OK：请求成功</li><li>301 Moved Permanently：请求的对象永久转移</li><li>400 Bad Request：通用差错代码，服务器不能理解请求</li><li>404 Not Found：被请求的文档不在服务器上。</li><li>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>HTTP响应报文中有一个cookie首部行</li><li>HTTP请求报文中有一个cookie首部行</li><li>用户端系统中保留有一个cookie文件，由浏览器进行管理</li><li>位于Web站点的后端数据库</li></ul><h3 id="Web缓存（Web-cache）"><a href="#Web缓存（Web-cache）" class="headerlink" title="Web缓存（Web cache）"></a>Web缓存（Web cache）</h3><p>又叫代理服务器（proxy server）</p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>域名系统（Domain Name System)</li><li>进行主机名到IP地址转换的目录服务</li><li>DNS是由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li><li>运行在UDP协议之上，使用53号端口</li><li>同一台用户主机上运行着DNS应用的客户端，浏览器从URL中抽取出主机名，并将这台主机名传给DNS应用的客户端，DNS客户向DNS服务器发送一个包含主机名的请求，DNS客户最终收到一份回答报文，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。</li><li>根DNS服务器/顶级域（DNS）服务器/权威DNS服务器/本地DNS服务器</li><li>DNS缓存</li></ul><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层协议只能工作在端系统</p><p>一个进程有一个或多个套接字（socket），每个套接字有唯一的标识符，标识符的格式决定它是UDP还是TCP套接字</p><p>多路分解（demultiplexing）：将运输层报文段中的数据交付到正确的套接字的工作</p><p>多路复用（multiplexing）：在源主机从不同的套接字中收集数据块，并为每个数据块封装上部首信息从而生成报文段，然后将报文段传递到网络层。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>无连接运输，不会引入建立连接的时延</li><li>首部开销小 8字节</li><li>从应用进程中得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及其他的小字段，然后将形成的报文段交给网络层。</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li><p>可靠数据传输</p></li><li><p>拥塞控制</p></li><li><p>面向连接的运输</p></li><li><p>全双工服务（full-duplex service）</p><p>三次握手</p><ul><li>第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文端不包含应用层数据。但是在报文段的首部中的一个标志位（SYN比特）被置为1。这个报文段被称为SYN报文段，该报文段会被封装在一个IP数据报中，并发送给服务器。客户随机选择一个初始序号（client_isn)，置于序号字段中</li><li>第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器就会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个报文段称为SYNACK报文段，SYN比特为1，首部的确认号字段为client_isn+1，序号字段为服务器的初始序号（server_isn)</li><li>第三步：在收到SYNACK报文段后，客户也要为该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（将值server_isn+1放置到TCP报文段首部的确认字）。因此连接建立了，SYN比特置为0。第三个阶段可以在报文段负载中携带客户到服务器的数据</li></ul><p>终止连接：</p><p>​    客户TCP发送一个特殊的报文段，让其首部中的FIN比特被设置为1。服务器接收到该报文段后，回送一个确认报文段，即它自己的终止报文段，其FIN比特被置为1。最后，该客户对这个服务器的终止报文段进行确认。用于该连接的所有资源释放。</p></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层分组成为数据报</p><p>最大传送单元（MTU）：一个链路层帧能承载的最大数据量</p><p>IP数据报</p><p>IP协议：不可靠服务</p><p>IPv4</p><p>IPv6</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML常用标签</title>
    <link href="/2018/01/06/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2018/01/06/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>（超文本标记语言–HyperText Markup Language）</li><li><code>&lt;!DOCTYPE html&gt;</code> -文档类型（doctypes）</li><li><code>&lt;html&gt;&lt;/html&gt;</code> -这个元素包含整个页面的内容，也被称作根元素</li><li><code>&lt;head&gt;&lt;/head&gt;</code> -包含页面描述，css样式表，字符编码声明和想被搜索引擎搜索到的关键字等内容，不会被用户看到</li><li><code>&lt;body&gt;&lt;/body&gt;</code> -包含文本，图像，视频等想被用户看到的内容</li><li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> -指定文档使用的字符编码</li><li><code>&lt;title&gt;&lt;/title&gt;</code> -设置页面的标题，标题显示在浏览器标签页上</li><li><code>&lt;link rel=&quot;#&quot; href=&quot;#&quot; type=&quot;#&quot;&gt;</code> </li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;cssFile.css&quot;&gt;</code> -css样式表，href中填样式表的路径</li><li><code>&lt;script src=&quot;jsFile.js&quot;&gt;&lt;/script&gt;</code> -src填js文件的路径，该元素更适合放在文档尾部</li></ul><a id="more"></a><h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><ul><li><p>标题</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>......<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre></li><li><p>段落</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></li><li><p>列表</p><p>–无序列表(unordered lists)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>–有序列表(ordered lists)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre></li><li><p>跳转页面（HTTP GET请求）(anchor-锚)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">download</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>herf(<strong>h</strong>ypertext <strong>ref</strong>erence)：输入链接地址，相对路径，锚点（#xxx），发起请求（?name=juzi），伪协议（javascript:;）</p><p>target：打开链接的地方</p><p>​    target=”_black”：新建空白页面打开</p><p>​    target=”_self”：在本页面打开</p><p>​    target=”_parent”：在父页面打开</p><p>​    target=”_top”：在顶层窗口打开</p><p>​    后两个一般结合iframe使用</p><p>download：指示浏览器下载URL而不是导航到URL</p></li><li><p>跳转页面（HTTP POST请求 ）–form</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"username"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"password"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>没有提交按钮就无法提交form，如果没有，没有指定type的button会自动升级为submit按钮</p></li><li><p>input</p><p>文本：<code>&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;</code> </p><p>密码：<code>&lt;input type=&quot;password&quot; name=&quot;&quot;&gt;</code> </p><p>复选框：<code>&lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;</code></p><p>单选框：<code>&lt;input type=&quot;radio&quot; name=&quot;&quot; value=&quot;&quot;&gt;</code> name属性相同的为一组</p><p>更多：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input</a></p><p>用<code>&lt;label&gt;</code> 标签关联文本和输入框，点击文本选中输入框，for对应id</p><pre><code class="hljs html">1.<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></code></pre><pre><code class="hljs html">2.<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"xxx"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span>&gt;</span></code></pre><p>提交时不会提交没有name属性的值</p></li><li><p>描述列表(description list)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>description term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>description description<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>描述术语<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>描述列表的描述部分<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>橘子<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre></li><li><p><code>&lt;img&gt;</code> –图像</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"描述内容"</span>&gt;</span></code></pre></li><li><p><code>&lt;vidio&gt;&lt;/vidio&gt;</code> –视频</p></li><li><p><code>&lt;b&gt;&lt;/b&gt;</code> –粗体 </p></li><li><p><code>&lt;strong&gt;&lt;/strong&gt;</code> –粗体，强调语气 </p></li><li><p><code>&lt;abbr&gt;</code> –缩写</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Laugh Out Loud"</span>&gt;</span>LOL<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span></code></pre></li><li><p><code>&lt;i&gt;&lt;/i&gt;</code> –用于表现因某些原因需要区分普通文本的一系列文本,通常显示斜体</p></li><li><p><code>&lt;blockquote&gt;&lt;/blockquote&gt;</code> –引用内容</p></li><li><p><code>&lt;hr&gt;</code> –分割线 </p></li><li><p><code>&lt;u&gt;&lt;/u&gt;</code> –下划线</p></li><li><p><code>&lt;br&gt;</code> –换行</p></li><li><p><code>&lt;kdb&gt;&lt;/kdb&gt;</code> –用于表示键盘输入</p></li><li><p><code>&lt;code&gt;</code> –代码</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Regular text. <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>This is code.<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> Regular text.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></li><li><p><code>&lt;nav&gt;</code> –导航栏</p></li></ul>  <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></code></pre><ul><li><p><code>&lt;time&gt;</code> –用来表示时间和日期</p></li><li><p><code>&lt;div&gt;</code> –通用型流内容容器</p></li><li><p><code>&lt;span&gt;</code> –通用行内容器</p></li><li><p><code>&lt;button&gt;</code> –按钮</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"button"</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></li><li><p><code>iframe</code> 在一个页面中嵌入一个页面</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">name</span>=<span class="hljs-string">xxx</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">xxx</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://qq.com"</span>&gt;</span>QQ<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">xxx</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://baidu.com"</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>src中输入默认网址</p><p>target表示点击链接显示窗口的位置，此处在iframe中显示</p><p>frameborder边框 0为无边框</p></li><li><p><code>&lt;select&gt;</code>  –下拉框</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"group"</span> <span class="hljs-attr">multiple</span>&gt;</span> <span class="hljs-comment">&lt;!-- multiple 支持多选 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>第一组<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">disabled</span>&gt;</span>第二组<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <span class="hljs-comment">&lt;!-- 不可选 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">selected</span>&gt;</span>第三组<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <span class="hljs-comment">&lt;!-- 默认选择 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p><code>&lt;textarea&gt;</code>  – 多行纯文本编辑控件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">"50"</span>&gt;</span>  Write something here<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></code></pre></li><li><p><code>&lt;table&gt;</code>  – 表格</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">1</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">width</span>=<span class="hljs-string">100</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">red</span> <span class="hljs-attr">width</span>=<span class="hljs-string">100</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></li><li><p><code>&lt;main&gt;&lt;/main&gt;</code> 呈现了文档<code>&lt;body&gt;</code> 或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。</p></li><li><p><code>&lt;article&gt;</code> 表示在文档，页面，应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构</p></li><li><p><code>&lt;aside&gt;</code> 表示一个和其他页面内容完全无关的部分</p></li><li><p><code>&lt;footer&gt;</code> 表示最近一个章节内容或根节点元素的页脚</p></li><li><p><code>&lt;header&gt;</code> 表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</p></li><li><p><code>&lt;section&gt;</code> 表示文档中的一个区域（或节）</p></li><li><p>查看所有元素 –<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element</a></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>特殊符号需要转义</p><pre><code class="hljs html"><span class="hljs-symbol">&amp;amp;</span></code></pre></li><li><p>http-server 超轻量级web服务器</p><p><a href="http://blog.csdn.net/qq_26562641/article/details/51396760" target="_blank" rel="noopener">http://blog.csdn.net/qq_26562641/article/details/51396760</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git命令</title>
    <link href="/2017/12/08/git%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2017/12/08/git%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h1><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name 你的英文名git<span class="hljs-built_in"> config </span>--global user.email 你的邮箱git<span class="hljs-built_in"> config </span>--global push.default matchinggit<span class="hljs-built_in"> config </span>--global core.quotepath <span class="hljs-literal">false</span>git<span class="hljs-built_in"> config </span>--global core.editor <span class="hljs-string">"vim"</span></code></pre><ul><li><p><code>git init</code> 初始化本地仓库</p></li><li><p><code>git status</code> 查看git状态</p></li><li><p>命名全局用户名和邮箱地址</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"yonghuming"</span>git<span class="hljs-built_in"> config </span>--global user.email youxiang@xxx.com</code></pre></li><li><p><code>git config --list</code> 查看所有设置</p></li><li><p><code>git add 文件名</code> 将文件添加到暂存区</p><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> index.html</span>git <span class="hljs-keyword">add</span><span class="bash"> . //把当前目录下所有变动加到暂存区</span></code></pre></li><li><p><code>git commit -m &quot;信息&quot;</code> 将你add过的内容正式提交到本地仓库</p><pre><code class="hljs pgsql">git <span class="hljs-keyword">commit</span> <span class="hljs-keyword">index</span>.html -m "添加index.html"git <span class="hljs-keyword">commit</span> . -m "添加了几个文件"</code></pre></li><li><p><code>git log</code> 查看变更历史</p></li><li><p><code>git clone</code> 下载仓库</p><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:xxxx</code></pre></li><li><p><code>git pull</code> 拉取最新版本到本地</p></li><li><p><code>git push</code> 向远程仓库推送代码</p></li><li><p><code>git rm --cached 文件名</code> 将暂存区文件删除</p></li><li><p><code>git checkout --文件名</code> 用暂存区文件覆盖工作目录中的文件</p></li><li><p><code>git reset --hard commitID</code> 回滚到本地仓库中特定版本并覆盖暂存区和工作目录</p></li></ul><ul><li><code>git remote add origin git@github.com:xxxxxxx.git</code> 将本地仓库与远程仓库关联</li><li><code>git remote set-url origin git@github.com:xxxxx.git</code> 上一步手抖了，可以用这个命令来挽回</li><li><code>git branch</code> 新建分支</li><li><code>git merge</code> 合并分支</li><li><code>git stash</code> 通灵术</li><li><code>git stash pop</code> 反转通灵术</li><li><code>git revert</code> 后悔了</li><li><code>git reset</code> 另一种后悔了</li><li><code>git diff</code> 查看详细变化</li></ul><h3 id="命令行技巧"><a href="#命令行技巧" class="headerlink" title="命令行技巧"></a>命令行技巧</h3><ul><li><p><code>~/.bashrc</code> </p><ol><li><p>首先 <code>touch ~/.bashrc</code> 创建一下这个文件</p></li><li><p>start ~/.bashrc 选用编辑器编辑这个文件，内容为 <code>echo &#39;Hi&#39;</code></p><p>你也可以用命令行编辑文件 <code>echo &quot;echo &#39;hi&#39;&quot; &gt;&gt; ~/.bashrc</code></p></li><li><p>关闭退出 Git Bash，然后打开 Git Bash，是不是看到了 Hi，这说明每次进入 Git Bash，就会优先运行 <code>~/.bashrc</code> 里面的命令</p></li><li><p>可以用<code>~/.bashrc</code> 在进入 Git Bash 前执行任何命令，十分方便。</p></li></ol></li><li><p><code>alias</code> </p><ol><li>在 ~/.bashrc 里新增一行 alias f=”echo ‘frank is awesome’”，等于号两边不能有空格</li><li>运行 source ~/.bashrc，作用是执行 ~/.bashrc</li><li>运行 f，就会看到 frank is awesome</li><li>也就是说，现在 f 就是 echo ‘frank is awesome’ 的缩写了，利用这个技巧，可以把很多常见的命令缩写一下</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>git与命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="/2017/12/03/%E5%AD%A6%E4%B9%A0Hexo/"/>
    <url>/2017/12/03/%E5%AD%A6%E4%B9%A0Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo是一款基于Node.js的静态博客框架，可部署到 GitHub Pages, Heroku 或其他平台。</p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网</a></p><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h3 id="在Github上创建个人仓库"><a href="#在Github上创建个人仓库" class="headerlink" title="在Github上创建个人仓库"></a>在Github上创建个人仓库</h3><p>注册Github账号：略</p><p>点击GitHub中的New repository创建新仓库，仓库名为：「Github用户名.github.io」</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>在<a href="https://git-scm.com/download" target="_blank" rel="noopener">官网</a>下载对应版本，具体参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></p><p>打开Git Bash，设置配置信息：</p><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">"你的GitHub用户名"</span>git config --global user.email <span class="hljs-string">"你的GitHub注册邮箱"</span></code></pre><p>检查电脑上现有的SSH Key:</p><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/.ssh 检查本机的ssh密钥</code></pre><p>生成新的 SSH Key文件：</p><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">"你的GitHub注册邮箱"</span>&lt;回车&gt;</code></pre><p>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>创建一个新的文件夹，可以命名为myBlog，进入该文件夹中，打开git bash</p><p>安装 Hexo成功，输入:</p><pre><code class="hljs bash">npm install -g hexo-cli</code></pre><p>初始化博客:</p><pre><code class="hljs bash">hexo init myBlog<span class="hljs-built_in">cd</span> myBlognpm i</code></pre><p>创建博客：</p><pre><code class="hljs bash">hexo new 博客名</code></pre><p>该命令会生成一个md文件，在该文件中编辑博客的内容</p><p>编辑完后，输入：</p><pre><code class="hljs bash">hexo server <span class="hljs-comment"># 简写 hexo s</span></code></pre><p>启动本地服务，在浏览器中访问显示的连接，即可查看到博客的内容</p><p>提交更新，输入：</p><pre><code class="hljs bash">hexo generate <span class="hljs-comment"># 简写 hexo g， 生成</span>hexo deploy <span class="hljs-comment"># 简写 hexo d， 部署</span></code></pre><p>进入「你的用户名.github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，就直接点击预览链接即可看到博客了</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2017/09/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/09/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>我也不知道要写啥</p><p><img src="http://pic.962.net/up/2017-5/2017517955518470.jpg" srcset="/img/loading.gif" alt="。。。。。。">  </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
